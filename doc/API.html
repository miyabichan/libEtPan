<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>libEtPan! API</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="LIBETPAN-API"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>libEtPan! API</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN6"
></A
>Viet Hoa DINH</H3
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2003 DINH Viet Hoa</P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN13"
>Introduction</A
></DT
><DT
>2. <A
HREF="#AEN16"
>Tools and datatypes</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN19"
>Array</A
></DT
><DD
><DL
><DT
><A
HREF="#CARRAY-NEW"
>carray_new and carray_free</A
></DT
><DT
><A
HREF="#CARRAY-SET-SIZE"
>carray_set_size</A
></DT
><DT
><A
HREF="#CARRAY-COUNT"
>carray_count, carray_add, carray_get and carray_set</A
></DT
><DT
><A
HREF="#CARRAY-DELETE"
>carray_delete</A
></DT
><DT
><A
HREF="#CARRAY-DATA"
>carray_data</A
></DT
></DL
></DD
><DT
><A
HREF="#CLIST"
>List</A
></DT
><DD
><DL
><DT
><A
HREF="#CLIST-NEW"
>clist_new and clist_free</A
></DT
><DT
><A
HREF="#CLIST-COUNT"
>clist_isempty and clist_count</A
></DT
><DT
><A
HREF="#CLIST-BEGIN"
>running through clist</A
></DT
><DT
><A
HREF="#CLIST-APPEND"
>clist modification</A
></DT
><DT
><A
HREF="#CLIST-FOREACH"
>clist_foreach</A
></DT
><DT
><A
HREF="#CLIST-CONCAT"
>clist_concat</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN161"
>Hash table</A
></DT
><DD
><DL
><DT
><A
HREF="#CHASH-NEW"
>chash_new and chash_free</A
></DT
><DT
><A
HREF="#CHASH-GET"
>chash_set and chash_get</A
></DT
><DT
><A
HREF="#CHASH-DELETE"
>chash_delete</A
></DT
><DT
><A
HREF="#CHASH-RESIZE"
>chash_resize</A
></DT
><DT
><A
HREF="#CHASH-BEGIN"
>running through the chash</A
></DT
><DT
><A
HREF="#CHASH-COUNT"
>chash_size and chash_count</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN229"
>Buffered I/O</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILSTREAM-SOCKET"
>socket stream</A
></DT
><DT
><A
HREF="#MAILSTREAM-SSL"
>TLS stream</A
></DT
></DL
></DD
><DT
><A
HREF="#MAILSTREAM-LOW"
>non-buffered I/O</A
></DT
><DT
><A
HREF="#AEN312"
>strings</A
></DT
><DD
><DL
><DT
><A
HREF="#MMAP-STRING-NEW"
>constructor and destructor</A
></DT
><DT
><A
HREF="#MMAP-STRING-ASSIGN"
>string value modification</A
></DT
><DT
><A
HREF="#MMAP-STRING-APPEND"
>insertion in string, deletion in string</A
></DT
><DT
><A
HREF="#MMAP-STRING-REF"
>referencing string</A
></DT
></DL
></DD
></DL
></DD
><DT
>3. <A
HREF="#IMF"
>Internet Message Format</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN397"
>Quick start</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN400"
>Parse message headers</A
></DT
><DT
><A
HREF="#AEN420"
>Render the message headers</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN425"
>Data types</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILIMF-MAILBOX"
>mailimf_mailbox - mailbox</A
></DT
><DT
><A
HREF="#MAILIMF-ADDRESS"
>mailimf_address - address</A
></DT
><DT
><A
HREF="#MAILIMF-MAILBOX-LIST"
>mailimf_mailbox_list - list of mailboxes</A
></DT
><DT
><A
HREF="#MAILIMF-ADDRESS-LIST"
>mailimf_address_list - list of addresses</A
></DT
><DT
><A
HREF="#MAILIMF-GROUP"
>mailimf_group - named group of mailboxes</A
></DT
><DT
><A
HREF="#MAILIMF-DATE-TIME"
>mailimf_date_time - date of a message</A
></DT
><DT
><A
HREF="#MAILIMF-ORIG-DATE"
>mailimf_orig_date - parsed content of date header</A
></DT
><DT
><A
HREF="#MAILIMF-FROM"
>mailimf_from - parsed content of From header</A
></DT
><DT
><A
HREF="#MAILIMF-SENDER"
>mailimf_sender - parsed content of Sender header</A
></DT
><DT
><A
HREF="#MAILIMF-REPLY-TO"
>mailimf_reply_to - parsed content of Reply-To header</A
></DT
><DT
><A
HREF="#MAILIMF-TO"
>mailimf_to - parsed content of To header</A
></DT
><DT
><A
HREF="#MAILIMF-CC"
>mailimf_cc - parsed content of Cc</A
></DT
><DT
><A
HREF="#MAILIMF-BCC"
>mailimf_bcc - parsed content of Bcc field</A
></DT
><DT
><A
HREF="#MAILIMF-MESSAGE-ID"
>mailimf_message_id - parsed content of Message-ID header</A
></DT
><DT
><A
HREF="#MAILIMF-IN-REPLY-TO"
>mailimf_in_reply_to - parsed content of In-Reply-To
        field</A
></DT
><DT
><A
HREF="#MAILIMF-REFERENCES"
>mailimf_references - parsed content of References field</A
></DT
><DT
><A
HREF="#MAILIMF-SUBJECT"
>mailimf_subject - parsed content of Subject field</A
></DT
><DT
><A
HREF="#MAILIMF-COMMENTS"
>mailimf_comments - parsed content of Comments field</A
></DT
><DT
><A
HREF="#MAILIMF-KEYWORDS"
>mailimf_keywords - parsed content of Keywords field</A
></DT
><DT
><A
HREF="#MAILIMF-RETURN"
>mailimf_return - parsed content of Return-Path field</A
></DT
><DT
><A
HREF="#MAILIMF-PATH"
>mailimf_path - address in Return-Path field</A
></DT
><DT
><A
HREF="#MAILIMF-OPTIONAL-FIELD"
>mailimf_optional_field - non-standard header</A
></DT
><DT
><A
HREF="#MAILIMF-FIELD"
>mailimf_field - header field</A
></DT
><DT
><A
HREF="#MAILIMF-FIELDS"
>mailimf_fields - list of header fields</A
></DT
><DT
><A
HREF="#MAILIMF-BODY"
>mailimf_body - message body without headers</A
></DT
><DT
><A
HREF="#MAILIMF-MESSAGE"
>mailimf_message - parsed message</A
></DT
><DT
><A
HREF="#MAILIMF-SINGLE-FIELDS"
>mailimf_single_fields - simplified fields</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1094"
>Parser functions</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILIMF-ADDRESS-LIST-PARSE"
>mailimf_address_list_parse</A
></DT
><DT
><A
HREF="#MAILIMF-ADDRESS-PARSE"
>mailimf_address_parse</A
></DT
><DT
><A
HREF="#MAILIMF-BODY-PARSE"
>mailimf_body_parse</A
></DT
><DT
><A
HREF="#MAILIMF-ENVELOPE-AND-OPTIONAL-FIELDS-PARSE"
>mailimf_envelope_and_optional_fields_parse</A
></DT
><DT
><A
HREF="#MAILIMF-ENVELOPE-FIELDS-PARSE"
>mailimf_envelope_fields_parse</A
></DT
><DT
><A
HREF="#MAILIMF-OPTIONAL-FIELDS-PARSE"
>mailimf_optional_fields_parse</A
></DT
><DT
><A
HREF="#MAILIMF-FIELDS-PARSE"
>mailimf_fields_parse</A
></DT
><DT
><A
HREF="#MAILIMF-IGNORE-FIELD-PARSE"
>mailimf_ignore_field_parse</A
></DT
><DT
><A
HREF="#MAILIMF-MAILBOX-LIST-PARSE"
>mailimf_mailbox_list_parse</A
></DT
><DT
><A
HREF="#MAILIMF-MAILBOX-PARSE"
>mailimf_mailbox_parse</A
></DT
><DT
><A
HREF="#MAILIMF-MESSAGE-PARSE"
>mailimf_message_parse</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1381"
>Creation functions</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILIMF-MAILBOX-LIST-ADD"
>mailimf_mailbox_list</A
></DT
><DT
><A
HREF="#MAILIMF-ADDRESS-LIST-ADD"
>mailimf_address_list</A
></DT
><DT
><A
HREF="#MAILIMF-FIELDS-ADD"
>mailimf_fields</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1556"
>Rendering of messages</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILIMF-FIELDS-WRITE"
>Header fields</A
></DT
></DL
></DD
></DL
></DD
><DT
>4. <A
HREF="#AEN1586"
>MIME</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1598"
>Quick start</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1601"
>Parse MIME message</A
></DT
><DT
><A
HREF="#AEN1609"
>Render the MIME message</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1614"
>Data types</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMIME-COMPOSITE-TYPE"
>mailmime_composite_type - Composite MIME type</A
></DT
><DT
><A
HREF="#MAILMIME-CONTENT"
>mailmime_content - MIME content type (Content-Type)</A
></DT
><DT
><A
HREF="#MAILMIME-DISCRETE-TYPE"
>mailmime_discrete_type - MIME discrete type</A
></DT
><DT
><A
HREF="#MAILMIME-FIELD"
>mailmime_field - MIME header field</A
></DT
><DT
><A
HREF="#MAILMIME-MECHANISM"
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</A
></DT
><DT
><A
HREF="#MAILMIME-FIELDS"
>mailmime_fields - header fields</A
></DT
><DT
><A
HREF="#MAILMIME-PARAMETER"
>mailmime_parameter - MIME type parameter</A
></DT
><DT
><A
HREF="#MAILMIME-TYPE"
>mailmime_type - MIME main type</A
></DT
><DT
><A
HREF="#MAILMIME-LANGUAGE"
>mailmime_language - Language of MIME part</A
></DT
><DT
><A
HREF="#MAILMIME-DATA"
>mailmime_data - Content of MIME part</A
></DT
><DT
><A
HREF="#MAILMIME"
>mailmime - MIME part</A
></DT
><DT
><A
HREF="#MAILMIME-DISPOSITION"
>mailmime_disposition - MIME disposition information (Content-Disposition)</A
></DT
><DT
><A
HREF="#MAILMIME-DISPOSITION-TYPE"
>mailmime_disposition_type - Type of MIME disposition</A
></DT
><DT
><A
HREF="#MAILMIME-DISPOSITION-PARM"
>mailmime_disposition_parm - MIME disposition parameter</A
></DT
><DT
><A
HREF="#MAILMIME-SINGLE-FIELDS"
>mailmime_single_fields - MIME headers</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN2180"
>Parser functions</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMIME-CONTENT-PARSE"
>mailmime_content_parse</A
></DT
><DT
><A
HREF="#MAILMIME-DESCRIPTION-PARSE"
>mailmime_description_parse</A
></DT
><DT
><A
HREF="#MAILMIME-ENCODING-PARSE"
>mailmime_encoding_parse</A
></DT
><DT
><A
HREF="#MAILMIME-FIELD-PARSE"
>mailmime_field_parse</A
></DT
><DT
><A
HREF="#MAILMIME-ID-PARSE"
>mailmime_id_parse</A
></DT
><DT
><A
HREF="#MAILMIME-FIELDS-PARSE"
>mailmime_fields_parse</A
></DT
><DT
><A
HREF="#MAILMIME-VERSION-PARSE"
>mailmime_version_parse</A
></DT
><DT
><A
HREF="#MAILMIME-PARAMETER-PARSE"
>mailmime_parameter_parse</A
></DT
><DT
><A
HREF="#MAILMIME-LANGUAGE-PARSE"
>mailmime_language_parse</A
></DT
><DT
><A
HREF="#MAILMIME-DISPOSITION-PARSE"
>mailmime_disposition_parse</A
></DT
><DT
><A
HREF="#MAILMIME-DISPOSITION-TYPE-PARSE"
>mailmime_disposition_type_parse</A
></DT
><DT
><A
HREF="#MAILMIME-ENCODED-PHRASE-PARSE"
>mailmime_encoded_phrase_parse</A
></DT
><DT
><A
HREF="#MAILMIME-PARSE"
>mailmime_parse</A
></DT
><DT
><A
HREF="#MAILMIME-BASE64-BODY-PARSE"
>mailmime_base64_body_parse</A
></DT
><DT
><A
HREF="#MAILMIME-QUOTED-PRINTABLE-BODY-PARSE"
>mailmime_quoted_printable_body_parse</A
></DT
><DT
><A
HREF="#MAILMIME-BINARY-BODY-PARSE"
>mailmime_binary_body_parse</A
></DT
><DT
><A
HREF="#MAILMIME-PART-PARSE"
>mailmime_part_parse</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN2583"
>Rendering of MIME parts</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMIME-FIELDS-WRITE"
>mailmime_fields_write, mailmime_content_write and
        mailmime_content_type_write</A
></DT
><DT
><A
HREF="#MAILMIME-WRITE"
>mailmime_write</A
></DT
><DT
><A
HREF="#MAILMIME-QUOTED-PRINTABLE-WRITE"
>mailmime_quoted_printable_write
        and mailmime_base64_write</A
></DT
><DT
><A
HREF="#MAILMIME-DATA-WRITE"
>mailmime_data_write</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN2669"
>Creation functions</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMIME-DISPOSITION-NEW-FILENAME"
>mailmime_disposition_new_filename and
        mailmime_disposition_new_with_data</A
></DT
><DT
><A
HREF="#MAILMIME-FIELDS-NEW-EMPTY"
>mailmime_fields_new_empty and mailmime_fields_add</A
></DT
><DT
><A
HREF="#MAILMIME-FIELDS-NEW-WITH-DATA"
>mailmime_fields_new_with_data and
        mailmime_fields_new_with_version</A
></DT
><DT
><A
HREF="#MAILMIME-GET-CONTENT-MESSAGE"
>mailmime_get_content_message</A
></DT
><DT
><A
HREF="#MAILMIME-DATA-NEW-DATA"
>mailmime_data_new_data and mailmime_data_new_file</A
></DT
><DT
><A
HREF="#MAILMIME-NEW-MESSAGE-DATA"
>mailmime_new_message_data, mailmime_new_empty and
        mailmime_new_with_content</A
></DT
><DT
><A
HREF="#MAILMIME-SET-PREAMBLE-FILE"
>mailmime_set_preamble_file, mailmime_set_epilogue_file,
        mailmime_set_preamble_text and mailmime_set_epilogue_text</A
></DT
><DT
><A
HREF="#MAILMIME-SET-BODY-FILE"
>mailmime_set_body_file and mailmime_set_body_text</A
></DT
><DT
><A
HREF="#MAILMIME-ADD-PART"
>mailmime_add_part, mailmime_remove_part,
        mailmime_smart_add_part and mailmime_smart_remove_part</A
></DT
><DT
><A
HREF="#MAILMIME-SET-IMF-FIELDS"
>mailmime_set_imf_fields</A
></DT
><DT
><A
HREF="#MAILMIME-FIELDS-NEW-ENCODING"
>mailmime_fields_new_encoding and
        mailmime_fields_new_filename</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN2946"
>Helper functions</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMIME-TRANSFER-ENCODING-GET"
>mailmime_transfer_encoding_get</A
></DT
><DT
><A
HREF="#MAILMIME-CONTENT-CHARSET-GET"
>mailmime_content_charset_get and
        mailmime_content_param_get</A
></DT
></DL
></DD
></DL
></DD
><DT
>5. <A
HREF="#AEN2988"
>Storages, folders, messages</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN2990"
>Introduction</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN2993"
>Message</A
></DT
><DT
><A
HREF="#AEN2996"
>MIME part</A
></DT
><DT
><A
HREF="#AEN2999"
>Mailbox</A
></DT
><DT
><A
HREF="#AEN3002"
>Storage</A
></DT
><DT
><A
HREF="#AEN3005"
>Folder</A
></DT
><DT
><A
HREF="#AEN3008"
>Session</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN3011"
>Error codes</A
></DT
><DT
><A
HREF="#AEN3015"
>Storage</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILSTORAGE-DRIVER"
>Storage driver</A
></DT
><DT
><A
HREF="#MAILSTORAGE"
>Storage</A
></DT
><DT
><A
HREF="#MAILSTORAGE-NEW"
>mailstorage_new and mailstorage_free</A
></DT
><DT
><A
HREF="#MAILSTORAGE-CONNECT"
>mailstorage_connect and mailstorage_disconnect</A
></DT
><DT
><A
HREF="#AEN3074"
>IMAP storage</A
></DT
><DT
><A
HREF="#AEN3077"
>Example</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN3082"
>Folder</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILFOLDER-DRIVER"
>Folder driver</A
></DT
><DT
><A
HREF="#AEN3095"
>Folder</A
></DT
><DT
><A
HREF="#MAILFOLDER-NEW"
>mailfolder_new and mail_folder_free</A
></DT
><DT
><A
HREF="#MAILFOLDER-CONNECT"
>mailfolder_connect and mailfolder_disconnect</A
></DT
><DT
><A
HREF="#MAILFOLDER-NOOP"
>mailfolder_noop</A
></DT
><DT
><A
HREF="#MAILFOLDER-CHECK"
>mailfolder_check</A
></DT
><DT
><A
HREF="#MAILFOLDER-EXPUNGE"
>mailfolder_expunge</A
></DT
><DT
><A
HREF="#MAILFOLDER-STATUS"
>mailfolder_status</A
></DT
><DT
><A
HREF="#MAILFOLDER-APPEND-MESSAGE"
>mailfolder_append_message</A
></DT
><DT
><A
HREF="#MAILFOLDER-GET-MESSAGES-LIST"
>mailfolder_get_messages_list</A
></DT
><DT
><A
HREF="#MAILFOLDER-GET-ENVELOPES-LIST"
>mailfolder_get_envelopes_list</A
></DT
><DT
><A
HREF="#MAILFOLDER-GET-MESSAGE"
>mailfolder_get_message</A
></DT
><DT
><A
HREF="#MAILFOLDER-GET-MESSAGE-BY-UID"
>mailfolder_get_message_by_uid</A
></DT
><DT
><A
HREF="#AEN3193"
>Example</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN3198"
>Message</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILMESSAGE-DRIVER"
>Message driver</A
></DT
><DT
><A
HREF="#MAILMESSAGE"
>Message</A
></DT
><DT
><A
HREF="#MAILMESSAGE-NEW"
>mailmessage_new</A
></DT
><DT
><A
HREF="#MAILMESSAGE-INIT"
>mailmessage_init</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FLUSH"
>mailmessage_flush</A
></DT
><DT
><A
HREF="#MAILMESSAGE-CHECK"
>mailmessage_check</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-RESULT-FREE"
>mailmessage_fetch_result_free</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH"
>mailmessage_fetch</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-HEADER"
>mailmessage_fetch_header</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-BODY"
>mailmessage_fetch_body</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-SIZE"
>mailmessage_fetch_size</A
></DT
><DT
><A
HREF="#MAILMESSAGE-GET-BODYSTRUCTURE"
>mailmessage_get_bodystructure</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-SECTION"
>mailmessage_fetch_section</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-SECTION-HEADER"
>mailmessage_fetch_section_header</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-SECTION-MIME"
>mailmessage_fetch_section_mime</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-SECTION-BODY"
>mailmessage_fetch_section_body</A
></DT
><DT
><A
HREF="#MAILMESSAGE-FETCH-ENVELOPE"
>mailmessage_fetch_envelope</A
></DT
><DT
><A
HREF="#MAILMESSAGE-GET-FLAGS"
>mailmessage_get_flags</A
></DT
><DT
><A
HREF="#MAILMESSAGE-RESOLVE-SINGLE-FIELDS"
>mailmessage_resolve_single_fields</A
></DT
><DT
><A
HREF="#MAILMESSAGE-LIST"
>Message list</A
></DT
><DT
><A
HREF="#MAILMESSAGE-TREE"
>Message tree</A
></DT
><DT
><A
HREF="#MAIL-FLAGS"
>Message flags</A
></DT
><DT
><A
HREF="#AEN3467"
>Example</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN3472"
>Session</A
></DT
><DD
><DL
><DT
><A
HREF="#MAILSESSION-DRIVER"
>Session driver</A
></DT
><DT
><A
HREF="#MAILSESSION"
>Session</A
></DT
><DT
><A
HREF="#AEN3670"
>mailsession_parameters</A
></DT
><DT
><A
HREF="#AEN3674"
>mailsession_connect_stream</A
></DT
><DT
><A
HREF="#AEN3678"
>mailsession_connect_path</A
></DT
><DT
><A
HREF="#AEN3682"
>mailsession_starttls</A
></DT
><DT
><A
HREF="#AEN3686"
>mailsession_login</A
></DT
><DT
><A
HREF="#AEN3690"
>mailsession_logout</A
></DT
><DT
><A
HREF="#AEN3694"
>mailsession_noop</A
></DT
><DT
><A
HREF="#AEN3698"
>mailsession_check_folder</A
></DT
><DT
><A
HREF="#AEN3702"
>mailsession_select_folder</A
></DT
><DT
><A
HREF="#AEN3706"
>mailsession_expunge_folder</A
></DT
><DT
><A
HREF="#AEN3710"
>mailsession_status_folder</A
></DT
><DT
><A
HREF="#AEN3714"
>mailsession_messages_number</A
></DT
><DT
><A
HREF="#AEN3718"
>mailsession_recent_number</A
></DT
><DT
><A
HREF="#AEN3722"
>mailsession_unseen_number</A
></DT
><DT
><A
HREF="#AEN3726"
>mailsession_append_message</A
></DT
><DT
><A
HREF="#AEN3730"
>mailsession_get_messages_list</A
></DT
><DT
><A
HREF="#AEN3734"
>mailsession_get_envelopes_list</A
></DT
><DT
><A
HREF="#AEN3741"
>mailsession_get_message</A
></DT
><DT
><A
HREF="#AEN3750"
>mailsession_get_message_by_uid</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Examples</B
></DT
><DT
>2-1. <A
HREF="#AEN35"
>carray creation</A
></DT
><DT
>2-2. <A
HREF="#AEN45"
>preallocating carray</A
></DT
><DT
>2-3. <A
HREF="#AEN66"
>carray access</A
></DT
><DT
>2-4. <A
HREF="#AEN79"
>deletion in carray</A
></DT
><DT
>2-5. <A
HREF="#AEN101"
>clist creation</A
></DT
><DT
>2-6. <A
HREF="#AEN129"
>displaying content of clist</A
></DT
><DT
>2-7. <A
HREF="#AEN145"
>deleting elements in a clist</A
></DT
><DT
>2-8. <A
HREF="#AEN158"
>merging two clists</A
></DT
><DT
>2-9. <A
HREF="#AEN191"
>chash insert and lookup</A
></DT
><DT
>2-10. <A
HREF="#AEN198"
>key deletion in a chash</A
></DT
><DT
>2-11. <A
HREF="#AEN219"
>running through a chash</A
></DT
><DT
>3-1. <A
HREF="#AEN431"
>example of mailbox</A
></DT
><DT
>3-2. <A
HREF="#AEN438"
>mailbox creation and display</A
></DT
><DT
>3-3. <A
HREF="#AEN465"
>address creation and display</A
></DT
><DT
>3-4. <A
HREF="#AEN480"
>Creation and display of mailimf_mailbox_list</A
></DT
><DT
>3-5. <A
HREF="#AEN495"
>creation and display of list of addresses</A
></DT
><DT
>3-6. <A
HREF="#AEN502"
>example of group</A
></DT
><DT
>3-7. <A
HREF="#AEN515"
>creation and display of a group</A
></DT
><DT
>3-8. <A
HREF="#AEN522"
>example of date</A
></DT
><DT
>3-9. <A
HREF="#AEN553"
>creation and display of date</A
></DT
><DT
>3-10. <A
HREF="#AEN569"
>creation and display of Date field</A
></DT
><DT
>3-11. <A
HREF="#AEN585"
>creation and display of a From header</A
></DT
><DT
>3-12. <A
HREF="#AEN601"
>creation and display of Sender field</A
></DT
><DT
>3-13. <A
HREF="#AEN616"
>creation and display of Reply-To field</A
></DT
><DT
>3-14. <A
HREF="#AEN632"
>creation and display of To field</A
></DT
><DT
>3-15. <A
HREF="#AEN648"
>creation and display of Cc field</A
></DT
><DT
>3-16. <A
HREF="#AEN664"
>creation and display of Bcc field</A
></DT
><DT
>3-17. <A
HREF="#AEN673"
>example of Message-ID</A
></DT
><DT
>3-18. <A
HREF="#AEN684"
>creation and display of Message-ID field</A
></DT
><DT
>3-19. <A
HREF="#AEN702"
>creation and display of In-Reply-To field</A
></DT
><DT
>3-20. <A
HREF="#AEN720"
>creation and display of References field</A
></DT
><DT
>3-21. <A
HREF="#AEN734"
>creation and display of Subject field</A
></DT
><DT
>3-22. <A
HREF="#AEN748"
>creation and display of Comment field</A
></DT
><DT
>3-23. <A
HREF="#AEN763"
>creation and display of Keywords field</A
></DT
><DT
>3-24. <A
HREF="#AEN778"
>creation and display of Return-Path field</A
></DT
><DT
>3-25. <A
HREF="#AEN794"
>Creation and display of return path</A
></DT
><DT
>3-26. <A
HREF="#AEN814"
>creation and display of non-standard fields</A
></DT
><DT
>3-27. <A
HREF="#AEN961"
>creation and display of field</A
></DT
><DT
>3-28. <A
HREF="#AEN977"
>creation and display of header fields</A
></DT
><DT
>3-29. <A
HREF="#AEN997"
>creation and display of message body</A
></DT
><DT
>3-30. <A
HREF="#AEN1017"
>creation and display of message</A
></DT
><DT
>3-31. <A
HREF="#AEN1088"
>using mailimf_single_fields</A
></DT
><DT
>3-32. <A
HREF="#AEN1091"
>using mailimf_single_fields without memory allocation</A
></DT
><DT
>3-33. <A
HREF="#AEN1120"
>parsing a list of addresses</A
></DT
><DT
>3-34. <A
HREF="#AEN1147"
>parsing an address</A
></DT
><DT
>3-35. <A
HREF="#AEN1174"
>parsing a message body</A
></DT
><DT
>3-36. <A
HREF="#AEN1201"
>parsing commonly used fields and return other fields
          in a non-parsed form</A
></DT
><DT
>3-37. <A
HREF="#AEN1228"
>parsing commonly used fields</A
></DT
><DT
>3-38. <A
HREF="#AEN1255"
>parsing optional fields</A
></DT
><DT
>3-39. <A
HREF="#AEN1282"
>parsing header fields</A
></DT
><DT
>3-40. <A
HREF="#AEN1304"
>skipping fields</A
></DT
><DT
>3-41. <A
HREF="#AEN1329"
>parsing a list of mailboxes</A
></DT
><DT
>3-42. <A
HREF="#AEN1354"
>parsing a mailbox</A
></DT
><DT
>3-43. <A
HREF="#AEN1378"
>parsing a message</A
></DT
><DT
>3-44. <A
HREF="#AEN1411"
>creating a list of mailboxes</A
></DT
><DT
>3-45. <A
HREF="#AEN1553"
>creation of header fields</A
></DT
><DT
>3-46. <A
HREF="#AEN1583"
>rendering of fields</A
></DT
><DT
>4-1. <A
HREF="#AEN1635"
>create and display MIME composite type</A
></DT
><DT
>4-2. <A
HREF="#AEN1667"
>Creation and display of MIME content type</A
></DT
><DT
>4-3. <A
HREF="#AEN1691"
>Creation and display of MIME discrete type</A
></DT
><DT
>4-4. <A
HREF="#AEN1757"
>Creation and display of MIME header field</A
></DT
><DT
>4-5. <A
HREF="#AEN1784"
>Creation and display of MIME transfer encoding mechanism</A
></DT
><DT
>4-6. <A
HREF="#AEN1799"
>Creation and display of MIME fields</A
></DT
><DT
>4-7. <A
HREF="#AEN1821"
>Creation and display of MIME type parameter</A
></DT
><DT
>4-8. <A
HREF="#AEN1851"
>Creation and display of MIME main type</A
></DT
><DT
>4-9. <A
HREF="#AEN1864"
>Creation and display of language of MIME part</A
></DT
><DT
>4-10. <A
HREF="#AEN1906"
>Creation and display of MIME part content</A
></DT
><DT
>4-11. <A
HREF="#AEN2007"
>Creation and display of MIME part</A
></DT
><DT
>4-12. <A
HREF="#AEN2026"
>Creation and display of MIME disposition information</A
></DT
><DT
>4-13. <A
HREF="#AEN2041"
>Creation and display of MIME disposition type</A
></DT
><DT
>4-14. <A
HREF="#AEN2090"
>Creation and display of MIME disposition
          parameter</A
></DT
><DT
>4-15. <A
HREF="#AEN2177"
>Creation and display of single fields</A
></DT
><DT
>4-16. <A
HREF="#AEN2203"
>Parsing MIME content type</A
></DT
><DT
>4-17. <A
HREF="#AEN2227"
>Parsing MIME description</A
></DT
><DT
>4-18. <A
HREF="#AEN2251"
>parsing MIME encoding mechanism</A
></DT
><DT
>4-19. <A
HREF="#AEN2267"
>parsing MIME header field</A
></DT
><DT
>4-20. <A
HREF="#AEN2291"
>Parsing MIME content identifier</A
></DT
><DT
>4-21. <A
HREF="#AEN2307"
>parsing MIME header fields</A
></DT
><DT
>4-22. <A
HREF="#AEN2331"
>parsing MIME version</A
></DT
><DT
>4-23. <A
HREF="#AEN2356"
>parsing a MIME parameter</A
></DT
><DT
>4-24. <A
HREF="#AEN2380"
>Parsing the MIME content langage</A
></DT
><DT
>4-25. <A
HREF="#AEN2404"
>Parsing the MIME content disposition</A
></DT
><DT
>4-26. <A
HREF="#AEN2427"
>parsing a MIME content disposition type</A
></DT
><DT
>4-27. <A
HREF="#AEN2455"
>decoding a MIME encoded header string</A
></DT
><DT
>4-28. <A
HREF="#AEN2478"
>parsing a MIME message</A
></DT
><DT
>4-29. <A
HREF="#AEN2501"
>Parsing a base64 encoded part</A
></DT
><DT
>4-30. <A
HREF="#AEN2524"
>Parsing a quoted printable encoded part</A
></DT
><DT
>4-31. <A
HREF="#AEN2547"
>Parsing a binary encoded part</A
></DT
><DT
>4-32. <A
HREF="#AEN2580"
>Parsing a MIME encoded part</A
></DT
><DT
>4-33. <A
HREF="#AEN2610"
>rendering MIME header fields</A
></DT
><DT
>4-34. <A
HREF="#AEN2649"
>render base64 or quoted printable</A
></DT
><DT
>4-35. <A
HREF="#AEN2694"
>creating a MIME content disposition</A
></DT
><DT
>4-36. <A
HREF="#AEN2713"
>creating a MIME header fields list</A
></DT
><DT
>4-37. <A
HREF="#AEN2728"
>creating new fields</A
></DT
><DT
>4-38. <A
HREF="#AEN2746"
>Creating a MIME content type</A
></DT
><DT
>4-39. <A
HREF="#AEN2779"
>creating MIME content</A
></DT
><DT
>4-40. <A
HREF="#AEN2809"
>creating a MIME part</A
></DT
><DT
>4-41. <A
HREF="#AEN2837"
>setting preamble and epilogue</A
></DT
><DT
>4-42. <A
HREF="#AEN2861"
>creating a MIME part</A
></DT
><DT
>4-43. <A
HREF="#AEN2892"
>modifying MIME structure</A
></DT
><DT
>4-44. <A
HREF="#AEN2909"
>modifying MIME structure</A
></DT
><DT
>4-45. <A
HREF="#AEN2943"
>creating MIME fields with only Content-Transfer-Encoding</A
></DT
><DT
>4-46. <A
HREF="#AEN2960"
>extracting MIME encoding mechanism</A
></DT
><DT
>4-47. <A
HREF="#AEN2985"
>extracting information from MIME content type</A
></DT
><DT
>5-1. <A
HREF="#AEN3079"
>use of storage</A
></DT
><DT
>5-2. <A
HREF="#AEN3195"
>use of folder</A
></DT
><DT
>5-3. <A
HREF="#AEN3469"
>use of message</A
></DT
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN13"
></A
>Chapter 1. Introduction</H1
><P
>      This document will describe the API of libEtPan!
    </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN16"
></A
>Chapter 2. Tools and datatypes</H1
><P
>      libEtPan! include a collection of datatypes such as lists,
      arrays, hash tables and tools such as buffered I/O.
    </P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN19"
>Array</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

typedef struct carray_s carray;
      </PRE
><P
>        <B
CLASS="COMMAND"
>carray</B
> is an array of pointers that will
        resize automatically in case a new element is added.
      </P
><P
>      
        The <B
CLASS="COMMAND"
>carray</B
> is implemented with an array
        <B
CLASS="COMMAND"
>(void **)</B
> that can be resized. An array has a
        size: this is the number of elements that can be added before
        the table is resized. It also has a count of elements: this is
        the elements that exist in the array.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CARRAY-NEW"
>carray_new and carray_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>carray * carray_new(unsigned int initsize);

void carray_free(carray * array);
        </PRE
><P
>          <B
CLASS="COMMAND"
>carray_new()</B
> creates a new array with an
          initial size. The array is not resized until the number of
          element reach the initial size. It returns
          <B
CLASS="COMMAND"
>NULL</B
> in case of failure.
        </P
><P
>          <B
CLASS="COMMAND"
>carray_free()</B
> releases memory used by the
          given array.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN35"
></A
><P
><B
>Example 2-1. carray creation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 50

int main(void)
{
  carray * a;

  a = carray_new(SIZE);
  if (a == NULL)
    exit(EXIT_FAILURE);
  
  /* do things here */
  
  carray_free(a);
  
  exit(EXIT_SUCESS);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CARRAY-SET-SIZE"
>carray_set_size</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int carray_set_size(carray * array, uint32_t new_size);
        </PRE
><P
>          <B
CLASS="COMMAND"
>carray_set_size()</B
> sets the size of the
          array. It returns <B
CLASS="COMMAND"
>0</B
> in case of success,
          <B
CLASS="COMMAND"
>-1</B
> in case of failure.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN45"
></A
><P
><B
>Example 2-2. preallocating carray</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 50
#define NEWSIZE 200

int main(void)
{
  carray * a;
  unsigned int i;
  char p[500];
  
  a = carray_new(SIZE);
  if (a == NULL)
    goto err;
  
  r = carray_set_size(NEWSIZE);
  if (r &lt; 0)
    goto free;
  
  for(i = 0 ; i &lt; NEWSIZE ; i ++)
    carray_set(a, i, &amp;p[i]);
  
  /* do things here */
  
  carray_free(a);
  
  exit(EXIT_SUCESS);
  
 free:
  carray_free(a);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CARRAY-COUNT"
>carray_count, carray_add, carray_get and carray_set</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int carray_count(carray);

int carray_add(carray * array, void * data, unsigned int * index);

void * carray_get(carray * array, unsigned int indx);

void carray_set(carray * array, unsigned int indx, void * value);
        </PRE
><P
>          <B
CLASS="COMMAND"
>carray_count()</B
> returns the number of
          elements in the <B
CLASS="COMMAND"
>carray</B
>.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>carray_add()</B
>adds an element at the end of
          the array. The <B
CLASS="COMMAND"
>index</B
> of the element is
          returns in <B
CLASS="COMMAND"
>(* index)</B
> if
          <B
CLASS="COMMAND"
>index</B
> is not <B
CLASS="COMMAND"
>NULL</B
>. It
          returns <B
CLASS="COMMAND"
>0</B
> in case of success,
          <B
CLASS="COMMAND"
>-1</B
> in case of failure.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>carray_get()</B
> returns the elements contained
          at the given cell of the table.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>carray_set()</B
> replace the element at the
          given index of table table with the given value.
          Complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN66"
></A
><P
><B
>Example 2-3. carray access</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;string.h&gt;

#define SIZE 50

int main(void)
{
  carray * a;
  int r;
  
  a = carray_new(SIZE);
  if (a == NULL)
    goto err;
    
  r = carray_add(a, "foo-bar-1", NULL);
  if (r &lt; 0)
    goto free;
    
  carray_add(a, "foo-bar-2", NULL);
  if (r &lt; 0)
    goto free;

  carray_add(a, "foo-bar-3", NULL);
  if (r &lt; 0)
    goto free;
  
  for(i = 0 ; i &lt; carray_count(a) ; i ++) {
    char * str;
    
    str = carray_get(a, i);
    if (strcmp("foo-bar-2", str) == 0)
      carray_set(a, i, "foo-bar-2-replacement");
    
    printf("%s\n", str);
  }
  
  carray_free(a);
  
  exit(EXIT_SUCESS);

 free:
  carray_free(a);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CARRAY-DELETE"
>carray_delete</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int carray_delete(carray * array, uint32_t indx);

int carray_delete_slow(carray * array, uint32_t indx);

int carray_delete_fast(carray * array, uint32_t indx);
        </PRE
><P
>          <B
CLASS="COMMAND"
>carray_delete()</B
> removes an element of the
          table. Order will not be garanteed. The returned result can
          be ignored.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>carray_delete_slow()</B
> removes an element of
          the table. Order will be garanteed. The returned result can
          be ignored.
          Complexity is O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>carray_delete_fast()</B
> the element will just
          be replaced with <B
CLASS="COMMAND"
>NULL</B
>. Order will be kept
          but the number of elements will remains the same. The
          returned result can be ignored.
          Complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN79"
></A
><P
><B
>Example 2-4. deletion in carray</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define SIZE 50

carray * build_array(void)
{
  carray * a;

  a = carray_new(SIZE);
  if (a == NULL)
    goto err;
  
  r = carray_add(a, "foo-bar-1", NULL);
  if (r &lt; 0)
    goto free;
    
  carray_add(a, "foo-bar-2", NULL);
  if (r &lt; 0)
    goto free;

  carray_add(a, "foo-bar-3", NULL);
  if (r &lt; 0)
    goto free;
  
  return a;

 free:
  carray_free(a);
 err:
  exit(EXIT_FAILURE);
}

void delete(carray * a)
{
  /* deleting foo-bar-1 */
  carray_delete(a, 0);
  /* resulting size is 2, order of elements is undefined */
}

void delete_slow(carray * a)
{
  /* deleting foo-bar-1 */
  carray_delete_slow(a, 0);
  /* resulting size is 2, order of elements is the same */
}

void delete_fast(carray * a)
{
  /* deleting foo-bar-1 */
  carray_delete_slow(a, 0);
  /* 
     resulting size is 3,
     order of elements is { NULL, foo-bar-2, foo-bar-3 }
  */
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CARRAY-DATA"
>carray_data</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>void ** carray_data(carray);
        </PRE
><P
>          <B
CLASS="COMMAND"
>carray_data</B
>returns the table used for
          implementation :
          <B
CLASS="COMMAND"
>(void **)</B
>.
        </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CLIST"
>List</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

typedef struct clist_s clist;

typedef clistcell clistiter;
      </PRE
><P
>        <B
CLASS="COMMAND"
>clist()</B
> is a list of cells.
        Each cell of the list contains one element. This element is a
        pointer. An iterator (<B
CLASS="COMMAND"
>clistiter</B
>) is a
        pointer to an element of the list. With an iterator, we can
        get the previous element of the list, the next element of the
        list and the content of the element.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-NEW"
>clist_new and clist_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>clist * clist_new(void);

void clist_free(clist *);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_new()</B
> allocates a new empty list and
          returns it.
        </P
><P
>          <B
CLASS="COMMAND"
>clist_free()</B
> frees the entire list with
          its cells.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN101"
></A
><P
><B
>Example 2-5. clist creation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  clist * list;

  list = clist_new();
  if (list == NULL)
    goto err;

  r = clist_append(list, "foo-bar");
  if (r &lt; 0)

  clist_free(list);

  exit(EXIT_SUCCESS);

 free:
  clist_free(list);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-COUNT"
>clist_isempty and clist_count</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int clist_isempty(clist *);

int clist_count(clist *);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_isempty()</B
> returns 1 if the list is
          empty, else it is 0.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_count()</B
> returns the number of
          elements in the list.
          Complexity is O(1).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-BEGIN"
>running through clist</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>clistiter * clist_begin(clist *);

clistiter * clist_end(clist *);

clistiter * clist_next(clistiter *);

clistiter * clist_previous(clistiter *);

void * clist_content(clistiter *);

void * clist_nth_data(clist * lst, int index);

clistiter * clist_nth(clist * lst, int index);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_begin()</B
> returns an iterator to the
          first element of the list.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_end()</B
> returns an iterator to the last
          element of the list.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_next()</B
> returns an iterator to the
          next element of the list.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_previous()</B
> returns an iterator to the
          previous element of the list.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_content()</B
> returns the element
          contained in the cell pointed by the iterator in the list.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_nth()</B
> returns an iterator on the
          <B
CLASS="COMMAND"
>index</B
>-th element of the list.
          Complexity is O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_nth_data()</B
> returns the index-th
          element of the list.
          Complexity is O(n).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN129"
></A
><P
><B
>Example 2-6. displaying content of clist</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  clist * list;
  clistiter * iter;

  list = build_string_list();
  if (list == NULL)
    goto err;

  for(iter = clist_begin(list) ; iter != NULL ; iter =
     clist_next(iter)) {
    char * str;

    str = clist_content(iter);
    printf("%s\n", str);
  }

  clist_free(list);

  exit(EXIT_SUCCESS);

 free:
  clist_free(list);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-APPEND"
>clist modification</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int clist_prepend(clist *, void *);

int clist_append(clist *, void *);

int clist_insert_before(clist *, clistiter *, void *);

int clist_insert_after(clist *, clistiter *, void *);

clistiter * clist_delete(clist *, clistiter *);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_prepend()</B
> adds an element at the
          beginning of the list. Returns 0 on sucess, -1 on error.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_append()</B
> adds an element at the end
          of the list. Returns 0 on sucess, -1 on error.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_insert_before()</B
> adds an element
          before the element pointed by the given iterator in the
          list. Returns 0 on sucess, -1 on error.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_insert_after()</B
> adds an element after
          the element pointed by the given iterator in the list.
          Returns 0 on sucess, -1 on error.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>clist_delete()</B
> the elements pointed by
          the given iterator in the list and returns an iterator to
          the next element of the list.
          Complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN145"
></A
><P
><B
>Example 2-7. deleting elements in a clist</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

voir print_content(void * content, void * user_data)
{
  char * str;

  str = content;

  printf("%s\n", str);
}

int main(void)
{
  clist * list;
  clistiter * iter;

  list = build_string_list();
  if (list == NULL)
    goto err;

  iter = = clist_begin(list);
  while (iter != NULL)
    char * str;

    str = clist_content(iter);
    if (strcmp(str, "foo-bar") == 0)
      iter = clist_delete(list, cur);
    else
      iter = clist_next(iter);
  }

  clist_foreach(list, print_content, NULL);
  printf("\n");

  clist_free(list);

  exit(EXIT_SUCCESS);

 free:
  clist_free(list);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-FOREACH"
>clist_foreach</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>typedef void (* clist_func)(void *, void *);

void clist_foreach(clist * lst, clist_func func, void * data);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_foreach()</B
> apply a fonction to each
          element of the list.
          Complexity is O(n).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLIST-CONCAT"
>clist_concat</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>void clist_concat(clist * dest, clist * src);
        </PRE
><P
>          <B
CLASS="COMMAND"
>clist_concat()</B
> adds all the elements of src
          at the end of dest. Elements are added in the same
          order. src is an empty list when the operation is finished.
          Complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN158"
></A
><P
><B
>Example 2-8. merging two clists</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  clist * list;
  clist * list_2;
  clistiter * iter;

  list = build_string_list();
  if (list == NULL)
    goto err;

  list_2 = build_string_list_2();
  if (list == NULL)
    goto free_list;

  clist_concat(list, list_2);
  clist_free(list_2);

  for(iter = clist_begin(list) ; iter != NULL ; iter =
     clist_next(iter)) {
    char * str;

    str = clist_content(iter);
    printf("%s\n", str);
  }

  clist_free(list);

  exit(EXIT_SUCCESS);

 free_list:
  clist_free(list);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN161"
>Hash table</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

typedef struct chash chash;

typedef struct chashcell chashiter;

typedef struct {
  char * data;
  int len;
} chashdatum;
      </PRE
><P
>      
        <B
CLASS="COMMAND"
>chash</B
> is a hash table.
        <B
CLASS="COMMAND"
>chashiter</B
> is a pointer to an element of the
        hash table.
        <B
CLASS="COMMAND"
>chashdatum</B
> is an element to be placed in
        the hash table as a key or a value. It consists in 
        data and a corresponding length.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-NEW"
>chash_new and chash_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#define CHASH_COPYNONE    0
#define CHASH_COPYKEY     1
#define CHASH_COPYVALUE   2
#define CHASH_COPYALL     (CHASH_COPYKEY | CHASH_COPYVALUE)

chash * chash_new(int size, int flags);

void chash_free(chash * hash);
        </PRE
><P
>          <B
CLASS="COMMAND"
>chash_new()</B
> returns a new empty hash table
          or <B
CLASS="COMMAND"
>NULL</B
> if this
          failed. <B
CLASS="COMMAND"
>size</B
> is the initial size of the
          table used for implementation. <B
CLASS="COMMAND"
>flags</B
> can
          be a combinaison of <B
CLASS="COMMAND"
>CHASH_COPYKEY</B
> and
          <B
CLASS="COMMAND"
>CHASH_COPYVALUE</B
>.
          <B
CLASS="COMMAND"
>CHASH_COPYKEY</B
> enables copy of key, so
          that the initial value used for <B
CLASS="COMMAND"
>chash_set()</B
>
        </P
><P
>          <B
CLASS="COMMAND"
>chash_free()</B
> releases memory used by the
          hash table.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-GET"
>chash_set and chash_get</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int chash_set(chash * hash,
    chashdatum * key, chashdatum * value, chashdatum * oldvalue);

int chash_get(chash * hash,
    chashdatum * key, chashdatum * result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>chash_set()</B
> adds a new element into the
          hash table. If a previous element had the same key, it is
          returns into oldvalue if <B
CLASS="COMMAND"
>oldvalue</B
> is
          different of NULL.
          Medium complexity is O(1).
        </P
><P
>          returns -1 if it fails, 0 on success.
        </P
><P
>          <B
CLASS="COMMAND"
>chash_get()</B
>returns the corresponding value
          of the given key. If there is no corresponding value, -1 is
          returned. 0 on success.
          Medium complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN191"
></A
><P
><B
>Example 2-9. chash insert and lookup</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(void)
{
  chash * hash;
  int r;
  chashdatum key;
  chashdatum value;
  char * str1 = "my-data";
  char * str2 = "my-data";

  hash = chash_new(CHASH_DEFAULTSIZE, CHASH_COPYNONE);

  key.data = "foo";
  key.len = strlen("foo");  
  value.data = str1;
  value.data = strlen(str1) + 1;
  /* + 1 is needed to get the terminal zero in the returned string */
  r = chash_set(hash, &amp;key, &amp;value, NULL);
  if (r &lt; 0)
    goto free_hash;

  key.data = "bar";
  key.len = strlen("bar");  
  value.data = str2;
  value.data = strlen(str2) + 1;
  if (r &lt; 0)
    goto free_hash;
  
  key.data = "foo";
  key.len = strlen("foo");  
  r = chash_get(hash, &amp;key, &amp;value);
  if (r &lt; 0) {
    printf("element not found\n");
  }
  else {
    char * str;

    str = value.data;
    printf("found : %s", str);
  }
  
  chash_free(hash);

  exit(EXIT_SUCCESS);

 free_hash:
  chash_free(hash);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-DELETE"
>chash_delete</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int chash_delete(chash * hash,
    chashdatum * key, chashdatum * oldvalue);
        </PRE
><P
>          deletes the key/value pair given the corresponding key.
          The value is returned in old_value.
          If there is no corresponding value, -1 is returned. 0 on success.
          Medium complexity is O(1).
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN198"
></A
><P
><B
>Example 2-10. key deletion in a chash</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(void)
{
  chash * hash;
  int r;
  chashdatum key;
  chashdatum value;
  char * str1 = "my-data";
  char * str2 = "my-data";

  hash = build_hash();
  
  key.data = "foo";
  key.len = strlen("foo");  
  chash_delete(hash, &amp;key, &amp;value);

  /* it will never be possible to lookup "foo" */
  key.data = "foo";
  key.len = strlen("foo");
  r = chash_get(hash, &amp;key, &amp;value);
  if (r &lt; 0) {
    printf("element not found\n");
  }
  else {
    char * str;

    str = value.data;
    printf("found : %s", str);
  }
  
  chash_free(hash);

  exit(EXIT_SUCCESS);

 free_hash:
  chash_free(hash);
 err:
  exit(EXIT_FAILURE);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-RESIZE"
>chash_resize</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int chash_resize(chash * hash, int size);
        </PRE
><P
>          <B
CLASS="COMMAND"
>chash_resize()</B
> changes the size of the
          table used for implementation of the hash table.
          returns 0 on success, -1 on failure.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-BEGIN"
>running through the chash</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>chashiter * chash_begin(chash * hash);

chashiter * chash_next(chash * hash, chashiter * iter);

void chash_key(chashiter * iter, chashdatum * result);

void chash_value(chashiter iter, chashdatum * result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>chash_begin()</B
> returns a pointer to the
          first element of the hash table. Returns
          <B
CLASS="COMMAND"
>NULL</B
> if there is no elements in the hash
          table.
          Complexity is O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>chash_next()</B
> returns a pointer to the next
          element of the hash table. Returns <B
CLASS="COMMAND"
>NULL</B
>
          if there is no next element.
          Complexity is O(n) but n calls to chash_next() also has 
          a complexity of O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>chash_key()</B
> returns the key of the given
          element of the hash table.
        </P
><P
>          <B
CLASS="COMMAND"
>chash_value</B
> returns the value of the
          given element of the hash table.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN219"
></A
><P
><B
>Example 2-11. running through a chash</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(void)
{
  chash * hash;
  int r;
  chashiter * iter;

  hash = build_hash();

  /* this will display all the values stored in the hash */
  for(iter = chash_begin(hash) ; iter != NULL ; iter =
    chash_next(hash, iter)) {
    chashdatum key;
    chashdatum value;
    char * str;

    chash_value(iter, &amp;value);
    str = value.data;
    printf("%s\n", str);
  }

  chash_free(hash);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHASH-COUNT"
>chash_size and chash_count</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int chash_size(chash * hash);

int chash_count(chash * hash);
        </PRE
><P
>          <B
CLASS="COMMAND"
>chash_size()</B
> returns the size of the table
          used for implementation of the hash table.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>chash_count()</B
> returns the number of
          elements in the hash table.
          Complexity is O(1).
        </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN229"
>Buffered I/O</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>      
#include &lt;libetpan/libetpan.h&gt;

typedef struct _mailstream mailstream;
      </PRE
><P
>        streams are objects where we can read data from and write data
        to. They are not seekable. That can be for example a pipe or a
        network stream.
      </P
><PRE
CLASS="PROGRAMLISTING"
>mailstream * mailstream_new(mailstream_low * low, size_t buffer_size);

int mailstream_close(mailstream * s);
      </PRE
><P
>        <B
CLASS="COMMAND"
>mailstream_new()</B
> creates a new stream
        stream with the low-level (see <A
HREF="#MAILSTREAM-LOW"
>the Section called <I
>non-buffered I/O</I
></A
>) 
        stream and a given buffer size.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_close()</B
> closes the stream.
        This function will be in charge to free the
        <B
CLASS="COMMAND"
>mailstream_low</B
> structure.
      </P
><PRE
CLASS="PROGRAMLISTING"
>      
ssize_t mailstream_write(mailstream * s, void * buf, size_t count);

int mailstream_flush(mailstream * s);

ssize_t mailstream_read(mailstream * s, void * buf, size_t count);

ssize_t mailstream_feed_read_buffer(mailstream * s);
      </PRE
><P
>        <B
CLASS="COMMAND"
>mailstream_write()</B
> writes a buffer to the
        given stream. This write operation will be buffered.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_flush()</B
> will force a write of
        all buffered data for a given stream.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_read()</B
> reads data from the
        stream to the given buffer.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_feed_read_buffer()</B
> this function
        will just fill the buffer for reading.
      </P
><PRE
CLASS="PROGRAMLISTING"
>      
mailstream_low * mailstream_get_low(mailstream * s);

void mailstream_set_low(mailstream * s, mailstream_low * low);
      </PRE
><P
>        <B
CLASS="COMMAND"
>mailstream_get_low()</B
> returns the low-level
        stream of the given stream.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_set_low()</B
> changes the low-level
        of the given stream. Useful, for 
        example, when a stream change from clear stream to SSL
        stream.
      </P
><PRE
CLASS="PROGRAMLISTING"
>char * mailstream_read_line(mailstream * stream, MMAPString * line);

char * mailstream_read_line_append(mailstream * stream, MMAPString * line);

char * mailstream_read_line_remove_eol(mailstream * stream, MMAPString * line);

char * mailstream_read_multiline(mailstream * s, size_t size,
    MMAPString * stream_buffer,
    MMAPString * multiline_buffer,
    size_t progr_rate,
    progress_function * progr_fun);
      </PRE
><P
>        <B
CLASS="COMMAND"
>mailstream_read_line()</B
> reads an entire line
        from the buffer and store it into the 
        given string. returns <B
CLASS="COMMAND"
>NULL</B
> on error, the
        corresponding array 
        of <B
CLASS="COMMAND"
>char</B
> is returned otherwise.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_read_line_append()</B
> reads an entire
        line from the buffer and appends it to the 
        given string. returns <B
CLASS="COMMAND"
>NULL</B
> on error, the
        array of char corresponding to the entire buffer is returned
        otherwise.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_read_line_remove_eol()</B
> reads an
        entire line from the buffer and store it into the 
        given string. All CR LF are removed.
        returns <B
CLASS="COMMAND"
>NULL</B
> on error, the corresponding
        array of <B
CLASS="COMMAND"
>char</B
> is returned otherwise.
      </P
><P
>        <B
CLASS="COMMAND"
>mailstream_read_multiline()</B
> reads a
        multiline data (several lines, the data are ended with 
        a single period '.')
        from the given stream and store it into the given
        multiline buffer (multiline_buffer). progr_rate should be 0
        and progr_fun <B
CLASS="COMMAND"
>NULL</B
> (deprecated things).
        <B
CLASS="COMMAND"
>stream_buffer</B
> is a buffer used for internal
        work of the function.
        size should be 0 (deprecated things).
      </P
><PRE
CLASS="PROGRAMLISTING"
>      
int mailstream_is_end_multiline(char * line);
      </PRE
><P
>        returns 1 if the line is an end of multiline data (a single
        period '.', eventually with CR and/or LF). 0 is returned
        otherwise.
      </P
><PRE
CLASS="PROGRAMLISTING"
>      
int mailstream_send_data(mailstream * s, char * message,
    size_t size,
    size_t progr_rate,
    progress_function * progr_fun);
      </PRE
><P
>        sends multiline data to the given stream.
        <B
CLASS="COMMAND"
>size</B
> is the size of the data.
        <B
CLASS="COMMAND"
>progr_rate</B
> and <B
CLASS="COMMAND"
>progr_fun</B
>
        are deprecated. <B
CLASS="COMMAND"
>progr_rate</B
> must be 0,
        <B
CLASS="COMMAND"
>progr_fun</B
> must be NULL.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSTREAM-SOCKET"
>socket stream</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>mailstream * mailstream_socket_open(int fd);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailstream_socket_open()</B
> will open a
          clear-text socket.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSTREAM-SSL"
>TLS stream</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>mailstream * mailstream_ssl_open(int fd);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailstream_ssl_open()</B
> will open a
          TLS/SSL socket.
        </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="MAILSTREAM-LOW"
>non-buffered I/O</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>      
#include &lt;libetpan/libetpan.h&gt;

struct mailstream_low_driver {
  ssize_t (* mailstream_read)(mailstream_low *, void *, size_t);
  ssize_t (* mailstream_write)(mailstream_low *, void *, size_t);
  int (* mailstream_close)(mailstream_low *);
  int (* mailstream_get_fd)(mailstream_low *);
  void (* mailstream_free)(mailstream_low *);
};

typedef struct mailstream_low_driver mailstream_low_driver;

struct _mailstream_low {
  void * data;
  mailstream_low_driver * driver;
};
        </PRE
><P
>        <B
CLASS="COMMAND"
>mailstream_low</B
> is a non-buffered stream.
      </P
><P
>        The <B
CLASS="COMMAND"
>mailstream_low_driver</B
> is a set of
        functions used to access the stream.
      </P
><P
></P
><UL
><LI
><P
>            <B
CLASS="COMMAND"
>mailstream_read/write/close()</B
> is the same
            interface as <B
CLASS="COMMAND"
>read/write/close()</B
>
            system calls, except that the file descriptor is replaced with the
            <B
CLASS="COMMAND"
>mailstream_low</B
> structure.
          </P
></LI
><LI
><P
>            <B
CLASS="COMMAND"
>mailstream_get_fd()</B
> returns the file
            descriptor used for this non-buffered stream.
          </P
></LI
><LI
><P
>            <B
CLASS="COMMAND"
>mailstream_free()</B
> is in charge to free
            the internal structure of the mailstream_low and the
            mailstream_low itself.
          </P
></LI
></UL
><PRE
CLASS="PROGRAMLISTING"
>      
mailstream_low * mailstream_low_new(void * data,
    mailstream_low_driver * driver);
      </PRE
><P
>        mailstream_low_new() creates a low-level mailstream with the
        given internal structure (data) and using the given set of
        functions (driver).
      </P
><PRE
CLASS="PROGRAMLISTING"
>      
ssize_t mailstream_low_write(mailstream_low * s, void * buf, size_t count);

ssize_t mailstream_low_read(mailstream_low * s, void * buf, size_t count);

int mailstream_low_close(mailstream_low * s);

int mailstream_low_get_fd(mailstream_low * s);

void mailstream_low_free(mailstream_low * s);
      </PRE
><P
>        Each of these calls will call the corresponding function defined
        in the driver.
      </P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN312"
>strings</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>      
#include &lt;libetpan/libetpan.h&gt;

struct _MMAPString
{
  char * str;
  size_t len;    
  size_t allocated_len;
  int fd;
  size_t mmapped_size;
};

typedef struct _MMAPString MMAPString;
      </PRE
><P
>        MMAPString is a string which size that can increase automatically.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MMAP-STRING-NEW"
>constructor and destructor</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>MMAPString * mmap_string_new(const char * init);

MMAPString * mmap_string_new_len(const char * init, size_t len);   

MMAPString * mmap_string_sized_new(size_t dfl_size);

void mmap_string_free(MMAPString * string);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mmap_string_new()</B
> allocates a new
          string. init is the intial value of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_new_len()</B
> allocates a new
          string. init is the intial value of the 
          string, len is the length of the initial string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_sized_new()</B
> allocates a new
          string. dfl_size is the initial allocation of 
          the string. <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_free()</B
> release the memory used
          by the string.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MMAP-STRING-ASSIGN"
>string value modification</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>MMAPString * mmap_string_assign(MMAPString * string, const char * rval);

MMAPString * mmap_string_truncate(MMAPString *string, size_t len);    
        </PRE
><P
>          <B
CLASS="COMMAND"
>mmap_string_assign()</B
> sets a new value for
          the given string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_truncate()</B
> sets a length for
          the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
><PRE
CLASS="PROGRAMLISTING"
>MMAPString * mmap_string_set_size (MMAPString * string, size_t len);
        </PRE
><P
>          sets the allocation of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MMAP-STRING-APPEND"
>insertion in string, deletion in string</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>MMAPString * mmap_string_insert_len(MMAPString * string, size_t pos,   
    const char * val, size_t len);  

MMAPString * mmap_string_append(MMAPString * string, const char * val);

MMAPString * mmap_string_append_len(MMAPString * string,
  const char * val, size_t len);  

MMAPString * mmap_string_append_c(MMAPString * string, char c);

MMAPString * mmap_string_prepend(MMAPString * string, const char * val);

MMAPString * mmap_string_prepend_c(MMAPString * string, char c);

MMAPString * mmap_string_prepend_len(MMAPString * string, const char * val,
  size_t len);  

MMAPString * mmap_string_insert(MMAPString * string, size_t pos,
  const char * val);

MMAPString * mmap_string_insert_c(MMAPString *string, size_t pos,
  char c);

MMAPString * mmap_string_erase(MMAPString * string, size_t pos,    
  size_t len);
        </PRE
><P
>          For complexity here, n is the size of the given MMAPString,
          and len is the size of the string to insert.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_insert_len()</B
> inserts the given
          string value of given length in the string at the given
          position. <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(n + len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_append()</B
> appends the given
          string value at the end of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_append_len()</B
> appends the
          given string value of given length at the end of the
          string. <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_append_c()</B
> appends the given
          character at the end of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(1).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_prepend()</B
> insert the given
          string value at the beginning of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(n + len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_prepend_c()</B
> insert the given
          character at the beginning of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_prepend_len()</B
> insert the given
          string value of given length at the beginning of the string.
          <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(n + len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_insert()</B
> inserts the given
          string value in the string at the given position.
          NULL will be returned on error.
          Complexity is O(n + len).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_insert_c()</B
> inserts the given
          character in the string at the given position.
          NULL will be returned on error.
          Complexity is O(n).
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_erase()</B
> removes the given
          count of characters (len) at the given position of the
          string. <B
CLASS="COMMAND"
>NULL</B
> will be returned on error.
          Complexity is O(n).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MMAP-STRING-REF"
>referencing string</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mmap_string_ref(MMAPString * string);

int mmap_string_unref(char * str);
        </PRE
><P
>          MMAPString provides a mechanism that let you use MMAPString
          like normal strings. You have first to use
          <B
CLASS="COMMAND"
>mmap_string_ref()</B
>, so that you notify
          that the string will be used as a normal string, then, you
          use <B
CLASS="COMMAND"
>mmapstr-&gt;str</B
> to refer to the
          string. When you have finished and you want to free a string
          corresponding to a <B
CLASS="COMMAND"
>MMAPString</B
>, you will
          use <B
CLASS="COMMAND"
>mmap_string_unref</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mmap_string_ref()</B
> references the string
          so that the array of characters can be used as a normal
          string then released with
          <B
CLASS="COMMAND"
>mmap_string_unref()</B
>.
          The array of characters will be obtained with string-&gt;str.
          returns -1 on error, 0 on success.
        </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="IMF"
></A
>Chapter 3. Internet Message Format</H1
><P
>      libEtPan! implements Internet Message parser. Currently, format
      is RFC 2822.
      This module also allows to generate messages.
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>        All allocation functions will take as argument allocated data
        and will store these data in the structure they will allocate.
        Data should be persistant during all the use of the structure
        and will be freed by the free function of the structure
      </P
><P
>        allocation functions will return <B
CLASS="COMMAND"
>NULL</B
> on failure

        functions returning integer will be returning one of the
        following error code:
        <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_PARSE</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_MEMORY</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_INVAL</B
>,
        or <B
CLASS="COMMAND"
>MAILIMF_ERROR_FILE</B
>.
      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN397"
>Quick start</A
></H2
><P
>        You will need this module when you want to parse headers
        of messages or when you want to build message headers
        conformant to standards.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN400"
>Parse message headers</A
></H3
><P
>          You will use one of the four following functions, depending
          on your needs :
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>mailimf_envelope_and_optional_fields_parse</B
>
              (<A
HREF="#MAILIMF-ENVELOPE-AND-OPTIONAL-FIELDS-PARSE"
>the Section called <I
>mailimf_envelope_and_optional_fields_parse</I
></A
>),
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mailimf_envelope_fields_parse</B
>
              (<A
HREF="#MAILIMF-ENVELOPE-FIELDS-PARSE"
>the Section called <I
>mailimf_envelope_fields_parse</I
></A
>),
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mailimf_optional_fields_parse</B
>
              (<A
HREF="#MAILIMF-OPTIONAL-FIELDS-PARSE"
>the Section called <I
>mailimf_optional_fields_parse</I
></A
>),
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mailimf_fields_parse</B
>
              (<A
HREF="#MAILIMF-FIELDS-PARSE"
>the Section called <I
>mailimf_fields_parse</I
></A
>).
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN420"
>Render the message headers</A
></H3
><P
>          Build your message headers, then use
          <B
CLASS="COMMAND"
>mailimf_fields_write</B
>
          (<A
HREF="#MAILIMF-FIELDS-WRITE"
>the Section called <I
>Header fields</I
></A
>)
          to render the headers.
        </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN425"
>Data types</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MAILBOX"
>mailimf_mailbox - mailbox</A
></H3
><P
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_mailbox {
  char * mb_display_name; /* can be NULL */
  char * mb_addr_spec;    /* != NULL */
};

struct mailimf_mailbox *
mailimf_mailbox_new(char * mb_display_name, char * mb_addr_spec);

void mailimf_mailbox_free(struct mailimf_mailbox * mailbox);
        </P
><P
>          This is an email mailbox with a display name.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN431"
></A
><P
><B
>Example 3-1. example of mailbox</B
></P
><PRE
CLASS="PROGRAMLISTING"
>DINH Viet Hoa &lt;hoa@users.sourceforge.net&gt;
          </PRE
></DIV
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_new</B
> creates and
          initializes a data structure with a value.
          Strings given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_free</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN438"
></A
><P
><B
>Example 3-2. mailbox creation and display</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_mailbox * mb;
  char * display_name;
  char * address;
  
  display_name = strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?=");
  address = strdup("dinh.viet.hoa@free.fr");
  mb = mailimf_mailbox_new(str, address);
  /* do the things */
  mailimf_mailbox_free(mb);
  
  return 0;
}

/* display mailbox information */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_mailbox(struct mailimf_mailbox * mb)
{
  if (mb-&gt;mb_display_name != NULL)
    printf("display name: %s\n", mb-&gt;mb_display_name);
  printf("address specifier : %s\n", mb-&gt;mb_addr_spec);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ADDRESS"
>mailimf_address - address</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_address {
  int ad_type;
  union {
    struct mailimf_mailbox * ad_mailbox; /* can be NULL */
    struct mailimf_group * ad_group;     /* can be NULL */
  } ad_data;
};

struct mailimf_address *
mailimf_address_new(int ad_type, struct mailimf_mailbox * ad_mailbox,
		    struct mailimf_group * ad_group);

void mailimf_address_free(struct mailimf_address * address);
          </PRE
><P
>          This is a mailbox or a group of mailbox.
        </P
><P
></P
><UL
><LI
><P
>            <B
CLASS="COMMAND"
>ad_type</B
> can be MAILIMF_ADDRESS_MAILBOX or
              <B
CLASS="COMMAND"
>MAILIMF_ADDRESS_GROUP</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>ad_data.ad_mailbox</B
> is a mailbox if
              <B
CLASS="COMMAND"
>ad_type</B
> is 
              <B
CLASS="COMMAND"
>MAILIMF_ADDRESS_MAILBOX</B
>
              see <A
HREF="#MAILIMF-MAILBOX"
>the Section called <I
>mailimf_mailbox - mailbox</I
></A
>)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>ad_data.group</B
> is a group if type is
              <B
CLASS="COMMAND"
>MAILIMF_ADDRESS_GROUP</B
>.
              see <A
HREF="#MAILIMF-GROUP"
>the Section called <I
>mailimf_group - named group of mailboxes</I
></A
>)
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_address_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_free</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN465"
></A
><P
><B
>Example 3-3. address creation and display</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* creates an address of type mailbox */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_address * a_mb;
  struct mailimf_mailbox * mb;
  char * display_name;
  char * address;
  
  display_name = strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?=");
  address = strdup("dinh.viet.hoa@free.fr");
  mb = mailimf_mailbox_new(str, address);
  
  a_mb = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  /* do the things */
  mailimf_address_free(a_mb);
}

/* creates an address of type group */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_address * a_g;
  struct mailimf_group * g;
  char * display_name;
  
  display_name = strdup("undisclosed-recipient");
  g = mailimf_group_new(display_name, NULL);
  
  a_g = mailimf_address_new(MAILIMF_ADDRESS_GROUP, NULL, g);
  /* do the things */
  mailimf_address_free(a_g);
  
  return 0;
}

/* display the content of an address */

#include &lt;libetpan/libetpan.h&gt;

void display_address(struct mailimf_address * a)
{
  clistiter * cur;

  switch (a-&gt;ad_type) {
    case MAILIMF_ADDRESS_GROUP:
      display_mailimf_group(a-&gt;ad_data.ad_group);
      break;

    case MAILIMF_ADDRESS_MAILBOX:
      display_mailimf_mailbox(a-&gt;ad_data.ad_mailbox);
      break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MAILBOX-LIST"
>mailimf_mailbox_list - list of mailboxes</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_mailbox_list {
  clist * mb_list; /* list of (struct mailimf_mailbox *), != NULL */
};

struct mailimf_mailbox_list *
mailimf_mailbox_list_new(clist * mb_list);

void mailimf_mailbox_list_free(struct mailimf_mailbox_list * mb_list);
        </PRE
><P
>          This is a list of mailboxes.
        </P
><P
>          <B
CLASS="COMMAND"
>mb_list</B
> is a list of mailboxes. This is a
          <B
CLASS="COMMAND"
>clist</B
> which elements are of type
          mailimf_mailbox (see <A
HREF="#MAILIMF-MAILBOX"
>the Section called <I
>mailimf_mailbox - mailbox</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_free()</B
> frees memory used by the
          structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN480"
></A
><P
><B
>Example 3-4. Creation and display of mailimf_mailbox_list</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* creates a list of mailboxes with two mailboxes */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_group * g;
  char * display_name;
  struct mailimf_mailbox_list * mb_list;
  clist * list;  
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  list = clist_append(mb);
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  list = clist_append(mb);
  
  mb_list = mailimf_mailbox_list_new(list);
  /* do the things */
  mailimf_mailbox_list_free(mb_list);
  
  return 0;
}

/* display a list of mailboxes */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_mailbox_list(struct mailimf_mailbox_list * mb_list)
{
  clistiter * cur;

  for(cur = clist_begin(mb_list-&gt;mb_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailimf_mailbox * mb;
    
    mb = clist_content(cur);
    
    display_mailbox(mb);
    printf("\n");
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ADDRESS-LIST"
>mailimf_address_list - list of addresses</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_address_list {
  clist * ad_list; /* list of (struct mailimf_address *), != NULL */
};

struct mailimf_address_list *
mailimf_address_list_new(clist * ad_list);

void mailimf_address_list_free(struct mailimf_address_list * addr_list);
        </PRE
><P
>          This is a list of addresses.
        </P
><P
>          <B
CLASS="COMMAND"
>ad_list</B
> is a list of addresses. This is a
          <B
CLASS="COMMAND"
>clist</B
> which elements are 
          of type mailimf_address (see <A
HREF="#MAILIMF-ADDRESS"
>the Section called <I
>mailimf_address - address</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_new()</B
> creates and
          initializes a data structure with 
          a value. Structures given as argument are referenced by the
          created object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_free()</B
> frees memory
          used by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN495"
></A
><P
><B
>Example 3-5. creation and display of list of addresses</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* creates a list of addresses with two addresses */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_address_list * addr_list;
  clist * list;  
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  list = clist_append(addr);
  
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  list = clist_append(addr);
  
  addr_list = mailimf_address_list_new(list);
  /* do the things */
  mailimf_address_list_free(mb_list);
  
  return 0;
}

/* display a list of addresses */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_address_list(struct mailimf_address_list * addr_list)
{
  clistiter * cur;

  for(cur = clist_begin(addr_list-&gt;ad_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailimf_address * addr;
    
    addr = clist_content(cur);
    
    display_address(addr);
    printf("\n");
  }
}
            </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-GROUP"
>mailimf_group - named group of mailboxes</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_group {
  char * grp_display_name; /* != NULL */
  struct mailimf_mailbox_list * grp_mb_list; /* can be NULL */
};

struct mailimf_group *
mailimf_group_new(char * grp_display_name,
    struct mailimf_mailbox_list * grp_mb_list);

void mailimf_group_free(struct mailimf_group * group);
        </PRE
><P
>          This is a list of mailboxes tagged with a name.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN502"
></A
><P
><B
>Example 3-6. example of group</B
></P
><PRE
CLASS="PROGRAMLISTING"
>            they play music: &lt;steve@morse.foo&gt;, &lt;neal@morse.foo&gt;,
            &lt;yngwie@malmsteen.bar&gt;, &lt;michael@romeo.bar&gt;;
          </PRE
></DIV
><P
>          <B
CLASS="COMMAND"
>grp_display_name</B
> is the name that will be
          displayed for this group,
          for example '<B
CLASS="COMMAND"
>group_name</B
>' in
          '<B
CLASS="COMMAND"
>group_name: address1@domain1,
            address2@domain2;</B
>'.
          This must be allocated with malloc().
          <B
CLASS="COMMAND"
>grp_mb_list</B
> is a list of mailboxes
          (see <A
HREF="#MAILIMF-MAILBOX-LIST"
>the Section called <I
>mailimf_mailbox_list - list of mailboxes</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_group_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_group_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN515"
></A
><P
><B
>Example 3-7. creation and display of a group</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* creates an empty group */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_group * g;
  char * display_name;
  
  display_name = strdup("undisclosed-recipient");
  g = mailimf_group_new(display_name, NULL);
  /* do the things */
  mailimf_group_free(g);
}

/* creates a group with two mailboxes */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_group * g;
  char * display_name;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_mailbox * mb;
  clist * list;  
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  list = clist_append(mb);
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  list = clist_append(mb);
  
  mb_list = mailimf_mailbox_list_new(list);
  
  display_name = strdup("my_group");
  g = mailimf_group_new(display_name, mb_list);
  /* do the things */
  mailimf_group_free(g);
  
  return 0;
}

/* display content of group */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_group(struct mailimf_group * group)
{
  printf("name of the group: %s\n", a-&gt;group-&gt;display_name);
  for(cur = clist_begin(a-&gt;group-&gt;mb_list-&gt;list) ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailimf_mailbox * mb;

    mb = clist_content(cur);
    display_mailbox(mb);
    printf("\n");
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-DATE-TIME"
>mailimf_date_time - date of a message</A
></H3
><P
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_date_time {
  int dt_day;
  int dt_month;
  int dt_year;
  int dt_hour;
  int dt_min;
  int dt_sec;
  int dt_zone;
};

struct mailimf_date_time *
mailimf_date_time_new(int dt_day, int dt_month, int dt_year,
    int dt_hour, int dt_min, int dt_sec, int dt_zone);

void mailimf_date_time_free(struct mailimf_date_time * date_time);
        </P
><P
>          This is the date and time of a message.
          For example :
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN522"
></A
><P
><B
>Example 3-8. example of date</B
></P
><PRE
CLASS="PROGRAMLISTING"
>Thu, 11 Dec 2003 00:15:02 +0100.
          </PRE
></DIV
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>dt_day</B
> is the day of month (1 to 31)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_month</B
> (1 to 12)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_year</B
> (4 digits)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_hour</B
> (0 to 23)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_min</B
> (0 to 59)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_sec</B
> (0 to 59)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dt_zone</B
> (this is the decimal value that
              we can read, for example: for
              '<B
CLASS="COMMAND"
>-0200</B
>', the value is
              <B
CLASS="COMMAND"
>-200</B
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_date_time_new()</B
> creates and
          initializes a date structure with a value.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_date_time_free()</B
> frees memory used
          by the structure.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN553"
></A
><P
><B
>Example 3-9. creation and display of date</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_date_time * d;
  
  d = mailimf_date_time_new(9, 5, 2003, 3, 01, 40, -0200);
  /* do the things */
  mailimf_date_time_free(d);
  
  return 0;
}

/* display the date */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_date(struct mailimf_date_time * d)
{
  printf("%02i/%02i/%i %02i:%02i:%02i %+04i\n",
    d-&gt;dt_day, d-&gt;dt_month, d-&gt;dt_year,
    d-&gt;dt_hour, d-&gt;dt_min, d-&gt;dt_sec, d-&gt;dt_zone);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ORIG-DATE"
>mailimf_orig_date - parsed content of date header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_orig_date {
  struct mailimf_date_time * dt_date_time; /* != NULL */
};

struct mailimf_orig_date * mailimf_orig_date_new(struct mailimf_date_time *
    dt_date_time);

void mailimf_orig_date_free(struct mailimf_orig_date * orig_date);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Date</B
> or
          <B
CLASS="COMMAND"
>Resent-Date</B
>.
          It encapsulates a mailimf_date_time
        </P
><P
>          <B
CLASS="COMMAND"
>dt_date_time</B
> is the parsed date
          (see <A
HREF="#MAILIMF-DATE-TIME"
>the Section called <I
>mailimf_date_time - date of a message</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_orig_date_new()</B
> creates and
          initializes a data structure with 
          a value. Structures given as argument are referenced by the
          created object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_orig_date_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN569"
></A
><P
><B
>Example 3-10. creation and display of Date field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_date_time * d;
  struct mailimf_orig_date * date;
  
  d = mailimf_date_time_new(9, 5, 2003, 3, 01, 40, -0200);
  date = mailimf_orig_date_new(d);
  /* do the things */
  mailimf_orig_date_free(date);
  
  return 0;
}

/* display date header */

#include &lt;libetpan/libetpan.h&gt;

void display_orig_date(struct mailimf_orig_date * orig_date)
{
  display_date_time(d-&gt;dt_date_time);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FROM"
>mailimf_from - parsed content of From header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_from {
  struct mailimf_mailbox_list * frm_mb_list; /* != NULL */
};

struct mailimf_from *
mailimf_from_new(struct mailimf_mailbox_list * frm_mb_list);

void mailimf_from_free(struct mailimf_from * from);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>From</B
> or
          <B
CLASS="COMMAND"
>Resent-From</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>frm_mb_list</B
> is the parsed mailbox list
          (see <A
HREF="#MAILIMF-MAILBOX-LIST"
>the Section called <I
>mailimf_mailbox_list - list of mailboxes</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_from_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_from_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN585"
></A
><P
><B
>Example 3-11. creation and display of a From header</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  clist * list;
  struct mailimf_mailbox * mb;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_from * from;
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  /* do the things */
  mailimf_from_free(from);
  
  return 0;
}

/* display content of from header */

#include &lt;libetpan/libetpan.h&gt;

void display_from(struct mailimf_from * from)
{
  display_mailbox_list(from-&gt;frm_mb_list);
}
            </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-SENDER"
>mailimf_sender - parsed content of Sender header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_sender {
  struct mailimf_mailbox * snd_mb; /* != NULL */
};

struct mailimf_sender * mailimf_sender_new(struct mailimf_mailbox * snd_mb);

void mailimf_sender_free(struct mailimf_sender * sender);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Sender</B
> or
          <B
CLASS="COMMAND"
>Resent-Sender</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>snd_mb</B
> is the parsed mailbox
          (see <A
HREF="#MAILIMF-MAILBOX"
>the Section called <I
>mailimf_mailbox - mailbox</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_sender_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_sender_free()</B
> This function frees
          memory used by the structure and substructures
          will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN601"
></A
><P
><B
>Example 3-12. creation and display of Sender field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_mailbox * mb;
  struct mailimf_sender * sender;
  
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  
  sender = mailimf_sender_new(mb);
  /* do the things */
  mailimf_sender_free(sender);
  
  return 0;
}

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_sender(struct mailimf_sender * sender)
{
  display_mailbox(sender-&gt;snd_mb);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-REPLY-TO"
>mailimf_reply_to - parsed content of Reply-To header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_reply_to {
  struct mailimf_address_list * rt_addr_list; /* != NULL */
};

struct mailimf_reply_to *
mailimf_reply_to_new(struct mailimf_address_list * rt_addr_list);

void mailimf_reply_to_free(struct mailimf_reply_to * reply_to);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Reply-To</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>addr_list</B
> is the parsed address list
          (see <A
HREF="#MAILIMF-ADDRESS-LIST"
>the Section called <I
>mailimf_address_list - list of addresses</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_reply_to_new()</B
> creates and
          initializes a data structure with a value. Structures given
          as argument are referenced by the created object and will be
          freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_reply_to_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN616"
></A
><P
><B
>Example 3-13. creation and display of Reply-To field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  clist * list;
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_address_list * addr_list;
  struct mailimf_reply_to * reply_to;
  
  list = clist_new();
  
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  addr_list = mailimf_address_list_new(list);
  
  reply_to = mailimf_reply_to_new(addr_list);
  /* do the things */
  mailimf_reply_to_free(reply_to);
  
  return 0;
}

/* display Reply-To header */

#include &lt;libetpan/libetpan.h&gt;

void display_reply_to(struct mailimf_reply_to * reply_to)
{
  display_address_list(reply_to-&gt;addr_list);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-TO"
>mailimf_to - parsed content of To header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>        struct mailimf_to {
  struct mailimf_address_list * to_addr_list; /* != NULL */
};

struct mailimf_to * mailimf_to_new(struct mailimf_address_list * to_addr_list);

void mailimf_to_free(struct mailimf_to * to);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>To</B
> or
          <B
CLASS="COMMAND"
>Resent-To</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>to_addr_list</B
> is the parsed address list
          (see <A
HREF="#MAILIMF-ADDRESS-LIST"
>the Section called <I
>mailimf_address_list - list of addresses</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_to_new()</B
> creates and initializes a
          data structure with a value. Structures given as argument
          are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_to_free()</B
> frees memory used by the
          structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN632"
></A
><P
><B
>Example 3-14. creation and display of To field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  clist * list;
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_address_list * addr_list;
  struct mailimf_to * to;
  
  list = clist_new();
  
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  addr_list = mailimf_address_list_new(list);
  
  to = mailimf_to_new(addr_list);
  /* do the things */
  mailimf_to_free(to);
  
  return 0;
}

/* display To header */

#include &lt;libetpan/libetpan.h&gt;

void display_to(struct mailimf_to * to)
{
  display_address_list(to-&gt;to_addr_list);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-CC"
>mailimf_cc - parsed content of Cc</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_cc {
  struct mailimf_address_list * cc_addr_list; /* != NULL */
};

struct mailimf_cc *
mailimf_cc_new(struct mailimf_address_list * cc_addr_list);

void mailimf_cc_free(struct mailimf_cc * cc);</PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Cc</B
> or
          <B
CLASS="COMMAND"
>Resent-Cc</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>cc_addr_list</B
> is the parsed address list
          (see <A
HREF="#MAILIMF-ADDRESS-LIST"
>the Section called <I
>mailimf_address_list - list of addresses</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_cc_new()</B
> creates and initializes a
          data structure with a value. Structures given as argument
          are referenced by the created object and will be freed if
          the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_cc_free()</B
> This function frees
          memory used by the structure and substructures will also be
          released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN648"
></A
><P
><B
>Example 3-15. creation and display of Cc field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  clist * list;
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_address_list * addr_list;
  struct mailimf_cc * cc;
  
  list = clist_new();
  
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  addr_list = mailimf_address_list_new(list);
  
  cc = mailimf_cc_new(addr_list);
  /* do the things */
  mailimf_cc_free(cc);
  
  return 0;
}

/* display content of Cc field */

#include &lt;libetpan/libetpan.h&gt;

void display_cc(struct mailimf_cc * cc)
{
  display_address_list(cc-&gt;cc_addr_list);
}

          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-BCC"
>mailimf_bcc - parsed content of Bcc field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_bcc {
  struct mailimf_address_list * bcc_addr_list; /* can be NULL */
};

struct mailimf_bcc *
mailimf_bcc_new(struct mailimf_address_list * bcc_addr_list);

void mailimf_bcc_free(struct mailimf_bcc * bcc);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Bcc</B
> or
          <B
CLASS="COMMAND"
>Resent-Bcc</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>bcc_addr_list</B
> is the parsed address list
          (see <A
HREF="#MAILIMF-ADDRESS-LIST"
>the Section called <I
>mailimf_address_list - list of addresses</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_bcc_new()</B
> creates and initializes a
          data structure with a value. Structures given as argument
          are referenced by the created object and will be freed if
          the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_bcc_free()</B
> frees memory used by the
          structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN664"
></A
><P
><B
>Example 3-16. creation and display of Bcc field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* create visible Bcc */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  clist * list;
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_address_list * addr_list;
  struct mailimf_bcc * bcc;
  
  list = clist_new();
  
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  mb = mailimf_mailbox_new(strdup("Christophe GIAUME"),
    strdup("christophe@giaume.com"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  
  addr_list = mailimf_address_list_new(list);
  
  bcc = mailimf_bcc_new(addr_list);
  /* do the things */
  mailimf_bcc_free(bcc);
  
  return 0;
}

/* create unvisible Bcc */

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_bcc * bcc;
  
  bcc = mailimf_bcc_new(NULL);
  /* do the things */
  mailimf_bcc_free(bcc);
  
  return 0;
}

/* display content of Bcc field */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_bcc(struct mailimf_bcc * bcc)
{
  if (bcc-&gt;addr_list == NULL) {
    printf("hidden Bcc\n");
  }
  else {
    display_address_list(bcc-&gt;bcc_addr_list);
  }
}
            </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MESSAGE-ID"
>mailimf_message_id - parsed content of Message-ID header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_message_id {
  char * mid_value; /* != NULL */
};

struct mailimf_message_id * mailimf_message_id_new(char * mid_value);

void mailimf_message_id_free(struct mailimf_message_id * message_id);
        </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Message-ID</B
>
          or <B
CLASS="COMMAND"
>Resent-Message-ID</B
>. For example :
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN673"
></A
><P
><B
>Example 3-17. example of Message-ID</B
></P
><PRE
CLASS="PROGRAMLISTING"
>Message-ID: &lt;200312100009.43592@c01n-c01n.plop.P4N&#62;&gt;
          </PRE
></DIV
><P
>          <B
CLASS="COMMAND"
>mid_value</B
> is the message identifier.
          It is not enclosed by angle bracket.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_message_id_new()</B
> This function
          creates and initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          The given string is allocated with
          <B
CLASS="COMMAND"
>malloc()</B
> and is not enclosed by angle bracket.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_message_id_free()</B
> frees memory
          used by the structure and substructures will also be
          released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN684"
></A
><P
><B
>Example 3-18. creation and display of Message-ID field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_message_id * msg_id;
  char * id;  
  
  id = strdup("1037197913.3dd26259752fa@imp.free.fr");
  msg_id = mailimf_message_id_new(id);
  /* do the things */
  mailimf_message_id_free(msg_id);
  
  return 0;
}

/* display message id */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_message_id(struct mailimf_message_id * msg_id)
{
  printf("%s\n", msg_id-&#62;mid_value);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-IN-REPLY-TO"
>mailimf_in_reply_to - parsed content of In-Reply-To
        field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_in_reply_to {
  clist * mid_list; /* list of (char *), != NULL */
};

struct mailimf_in_reply_to * mailimf_in_reply_to_new(clist * mid_list);

void mailimf_in_reply_to_free(struct mailimf_in_reply_to * in_reply_to);
        </PRE
><P
>          content of a header <B
CLASS="COMMAND"
>In-Reply-To</B
>.
          For example :
        </P
><PRE
CLASS="PROGRAMLISTING"
>In-Reply-To: &lt;etPan.3fd5fa29.4c3901c1.6b39@homer&gt;
        </PRE
><P
>          <B
CLASS="COMMAND"
>mid_list</B
> is a <B
CLASS="COMMAND"
>clist</B
>
          in which elements are message identifiers.
          their types are <B
CLASS="COMMAND"
>(char *)</B
> and they are
          allocated with <B
CLASS="COMMAND"
>malloc()</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_in_reply_to_new()</B
> creates and
          initializes a data structure with a value. Structures given
          as argument are referenced by the created object and will be
          freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_in_reply_to_free()</B
> frees memory
          used by the structure and substructures will also be
          released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN702"
></A
><P
><B
>Example 3-19. creation and display of In-Reply-To field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_in_reply_to * in_reply_to;
  clist * msg_id_list;  
  
  msg_id_list = clist_new();
  clist_append(msg_id_list,
    strdup("etPan.3ebbcc18.4014197f.bc1@homer.invalid"));
  
  in_reply_to = mailimf_in_reply_to_new(msg_id_list);
  /* do the things */
  mailimf_in_reply_to_free(in_reply_to);
  
  return 0;
}

/* display the content of mailimf_in_reply_to */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_in_reply_to(struct mailimf_in_reply_to * in_reply_to)
{
  clistiter * cur;
  
  for(cur = clist_begin(in_reply_to-&gt;mid_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    char * str;
    
    str = clist_content(cur);
    
    printf("%s\n", str);
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-REFERENCES"
>mailimf_references - parsed content of References field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_references {
  clist * mid_list; /* list of (char *) */
       /* != NULL */
};

struct mailimf_references * mailimf_references_new(clist * mid_list);

void mailimf_references_free(struct mailimf_references * references);
          </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>References</B
>.
          For example :
        </P
><PRE
CLASS="PROGRAMLISTING"
>In-Reply-To: &lt;etPan.3fd5fa29.4c3901c1.6b39@homer&gt;
  &lt;3FD5FA78.A1D98E7@oleane.net&gt;
  &lt;etPan.3fd5fc69.2b349482.730e@homer&gt;
        </PRE
><P
>          <B
CLASS="COMMAND"
>mid_list</B
> is a <B
CLASS="COMMAND"
>clist</B
>
          in which elements are message identifiers.
          their types are <B
CLASS="COMMAND"
>(char *)</B
> and they are
          allocated with <B
CLASS="COMMAND"
>malloc()</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_references_new()</B
> creates and
          initializes a data structure with a value. Structures given
          as argument are referenced by the created object and will be
          freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_references_free()</B
> frees memory
          used by the structure and substructures will also be
          released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN720"
></A
><P
><B
>Example 3-20. creation and display of References field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_references * ref;
  clist * msg_id_list;  
  
  msg_id_list = clist_new();
  clist_append(msg_id_list,
    strdup("200304280144.23633.wim.delvaux@adaptiveplanet.com"));
  clist_append(msg_id_list,
    strdup("200304301153.19688.wim.delvaux@adaptiveplanet.com"));
  clist_append(msg_id_list,
    strdup("etPan.3eb29de4.5fc4d652.3f83@homer"));
  
  ref = mailimf_references_new(msg_id_list);
  /* do the things */
  mailimf_in_reply_to_free(ref);
  
  return 0;
}

/* display references */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_references(struct mailimf_references * ref)
{
  clistiter * cur;

  for(cur = clist_begin(ref-&gt;mid_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    char * msg_id;
    
    msg_id = clist_content(cur);
    
    printf("%s\n", msg_id);
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-SUBJECT"
>mailimf_subject - parsed content of Subject field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_subject {
  char * sbj_value; /* != NULL */
};

struct mailimf_subject * mailimf_subject_new(char * sbj_value);

void mailimf_subject_free(struct mailimf_subject * subject);</PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Subject</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>sbj_value</B
> is the value of the field.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_subject_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_subject_free</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN734"
></A
><P
><B
>Example 3-21. creation and display of Subject field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_subject * subject;  

  subject = mailimf_subject_new(strdup("example of subject"));
  /* do the things */
  mailimf_subject_free(subject);
  
  return 0;
}

/* display subject header */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_subject(struct mailimf_subject * subject)
{
  printf("%s\n", subject-&#62;value);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-COMMENTS"
>mailimf_comments - parsed content of Comments field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_comments {
  char * cm_value; /* != NULL */
};

struct mailimf_comments * mailimf_comments_new(char * cm_value);

void mailimf_comments_free(struct mailimf_comments * comments);
          </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Comments</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>cm_value</B
> is the value of the field.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_comments_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_comments_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN748"
></A
><P
><B
>Example 3-22. creation and display of Comment field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_comments * comments;

  comments = mailimf_comments_new(strdup("example of comment"));
  /* do the things */
  mailimf_comments_free(comments);
  
  return 0;
}

/* display the content of a comments */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_comments(struct mailimf_comments * comments)
{
  printf("%s\n", comments-&#62;cm_value);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-KEYWORDS"
>mailimf_keywords - parsed content of Keywords field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_keywords {
  clist * kw_list; /* list of (char *), != NULL */
};

struct mailimf_keywords * mailimf_keywords_new(clist * kw_list);

void mailimf_keywords_free(struct mailimf_keywords * keywords);
          </PRE
><P
>          This is the content of a header <B
CLASS="COMMAND"
>Keywords</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>kw_list</B
> is the list of keywords. This is
          a list of <B
CLASS="COMMAND"
>(char *)</B
> allocated with malloc().
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_keywords_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_keywords_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN763"
></A
><P
><B
>Example 3-23. creation and display of Keywords field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_keywords * keywords;
  clist * list;
  
  list = clist_new();
  clist_append(list, strdup("sauerkraut"));
  clist_append(list, strdup("potatoes"));
  clist_append(list, strdup("cooking"));
  
  keywords = mailimf_keywords_new(list);
  /* do the things */
  mailimf_keywords_free(keywords);
  
  return 0;
}

/* display the content of mailimf_in_reply_to */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_keywords(struct mailimf_keywords * kw)
{
  clistiter * cur;
  
  for(cur = clist_begin(kw-&gt;kw_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    char * str;
    
    str = clist_content(cur);
    
    printf("%s\n", str);
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-RETURN"
>mailimf_return - parsed content of Return-Path field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_return {
  struct mailimf_path * ret_path; /* != NULL */
};

struct mailimf_return *
mailimf_return_new(struct mailimf_path * ret_path);

void mailimf_return_free(struct mailimf_return * return_path);
        </PRE
><P
>          This is the content of a header
          <B
CLASS="COMMAND"
>Return-Path</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>ret_path</B
> is the parsed value of Return-Path
          (see <A
HREF="#MAILIMF-PATH"
>the Section called <I
>mailimf_path - address in Return-Path field</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_return_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_return_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN778"
></A
><P
><B
>Example 3-24. creation and display of Return-Path field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_path * path;
  struct mailimf_return * r;
  
  path = mailimf_path_new(strdup("dinh.viet.hoa@free.fr"));
  r = mailimf_return_new(path);
  /* do the things */
  mailimf_return_free(r);
  
  return 0;
}

/* display return path */

#include &lt;libetpan/libetpan.h&gt;

void display_return(struct mailimf_return * r)
{
  display_path(r-&gt;ret_path);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-PATH"
>mailimf_path - address in Return-Path field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_path {
  char * pt_addr_spec; /* can be NULL */
};

struct mailimf_path * mailimf_path_new(char * pt_addr_spec);

void mailimf_path_free(struct mailimf_path * path);
        </PRE
><P
>          This is the encapsulation of address specifier for
          <B
CLASS="COMMAND"
>Return-Path</B
> content.
        </P
><P
>          <B
CLASS="COMMAND"
>pt_addr_spec</B
> is a mailbox destination.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_path_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          The given string is allocated with
          <B
CLASS="COMMAND"
>malloc()</B
>. This is a address
          specifier.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_path_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN794"
></A
><P
><B
>Example 3-25. Creation and display of return path</B
></P
><PRE
CLASS="PROGRAMLISTING"
>        
#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_path * path;
  
  path = mailimf_path_new(strdup("dinh.viet.hoa@free.fr"));
  /* do the things */
  mailimf_path_free(r);
  
  return 0;
}

/* display return path */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_path(struct mailimf_path * path)
{
  printf("%s\n", path-&gt;pt_addr_spec);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-OPTIONAL-FIELD"
>mailimf_optional_field - non-standard header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_optional_field {
  char * fld_name;  /* != NULL */
  char * fld_value; /* != NULL */
};

struct mailimf_optional_field *
mailimf_optional_field_new(char * fld_name, char * fld_value);

void mailimf_optional_field_free(struct mailimf_optional_field * opt_field);
        </PRE
><P
>          This is a non-standard header or unparsed header.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_name</B
> is the name of the header
              field.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_value</B
> is the value of the header
              field.
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_optional_field_new()</B
> This
          function creates and initializes a data structure with a
          value. Structures given as argument are referenced by the
          created object and will be freed if the object is released.
        </P
><P
>          field name and field value have to be allocated with
          <B
CLASS="COMMAND"
>malloc()</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_optional_field_free()</B
> This
          function frees memory used by the structure and 
          substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN814"
></A
><P
><B
>Example 3-26. creation and display of non-standard fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_optional_field * opt;
  
  opt = mailimf_optional_field_new(strdup("X-My-Field"), strdup("my value"));
  /* do the things */
  mailimf_optional_field_free(opt);
  
  return 0;
}

/* display the optional field */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_optional_field(struct mailimf_optional_field * opt)
{
  printf("%s: %s\n", opt-&gt;fld_name, opt-&gt;fld_value);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FIELD"
>mailimf_field - header field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILIMF_FIELD_NONE,           /* on parse error */
  MAILIMF_FIELD_RETURN_PATH,    /* Return-Path */
  MAILIMF_FIELD_RESENT_DATE,    /* Resent-Date */
  MAILIMF_FIELD_RESENT_FROM,    /* Resent-From */
  MAILIMF_FIELD_RESENT_SENDER,  /* Resent-Sender */
  MAILIMF_FIELD_RESENT_TO,      /* Resent-To */
  MAILIMF_FIELD_RESENT_CC,      /* Resent-Cc */
  MAILIMF_FIELD_RESENT_BCC,     /* Resent-Bcc */
  MAILIMF_FIELD_RESENT_MSG_ID,  /* Resent-Message-ID */
  MAILIMF_FIELD_ORIG_DATE,      /* Date */
  MAILIMF_FIELD_FROM,           /* From */
  MAILIMF_FIELD_SENDER,         /* Sender */
  MAILIMF_FIELD_REPLY_TO,       /* Reply-To */
  MAILIMF_FIELD_TO,             /* To */
  MAILIMF_FIELD_CC,             /* Cc */
  MAILIMF_FIELD_BCC,            /* Bcc */
  MAILIMF_FIELD_MESSAGE_ID,     /* Message-ID */
  MAILIMF_FIELD_IN_REPLY_TO,    /* In-Reply-To */
  MAILIMF_FIELD_REFERENCES,     /* References */
  MAILIMF_FIELD_SUBJECT,        /* Subject */
  MAILIMF_FIELD_COMMENTS,       /* Comments */
  MAILIMF_FIELD_KEYWORDS,       /* Keywords */
  MAILIMF_FIELD_OPTIONAL_FIELD, /* other field */
};

struct mailimf_field {
  int fld_type;
  union {
    struct mailimf_return * fld_return_path;              /* can be NULL */
    struct mailimf_orig_date * fld_resent_date;    /* can be NULL */
    struct mailimf_from * fld_resent_from;         /* can be NULL */
    struct mailimf_sender * fld_resent_sender;     /* can be NULL */
    struct mailimf_to * fld_resent_to;             /* can be NULL */
    struct mailimf_cc * fld_resent_cc;             /* can be NULL */
    struct mailimf_bcc * fld_resent_bcc;           /* can be NULL */
    struct mailimf_message_id * fld_resent_msg_id; /* can be NULL */
    struct mailimf_orig_date * fld_orig_date;             /* can be NULL */
    struct mailimf_from * fld_from;                       /* can be NULL */
    struct mailimf_sender * fld_sender;                   /* can be NULL */
    struct mailimf_reply_to * fld_reply_to;               /* can be NULL */
    struct mailimf_to * fld_to;                           /* can be NULL */
    struct mailimf_cc * fld_cc;                           /* can be NULL */
    struct mailimf_bcc * fld_bcc;                         /* can be NULL */
    struct mailimf_message_id * fld_message_id;           /* can be NULL */
    struct mailimf_in_reply_to * fld_in_reply_to;         /* can be NULL */
    struct mailimf_references * fld_references;           /* can be NULL */
    struct mailimf_subject * fld_subject;                 /* can be NULL */
    struct mailimf_comments * fld_comments;               /* can be NULL */
    struct mailimf_keywords * fld_keywords;               /* can be NULL */
    struct mailimf_optional_field * fld_optional_field;   /* can be NULL */
  } fld_data;
};

struct mailimf_field *
mailimf_field_new(int fld_type,
    struct mailimf_return * fld_return_path,
    struct mailimf_orig_date * fld_resent_date,
    struct mailimf_from * fld_resent_from,
    struct mailimf_sender * fld_resent_sender,
    struct mailimf_to * fld_resent_to,
    struct mailimf_cc * fld_resent_cc,
    struct mailimf_bcc * fld_resent_bcc,
    struct mailimf_message_id * fld_resent_msg_id,
    struct mailimf_orig_date * fld_orig_date,
    struct mailimf_from * fld_from,
    struct mailimf_sender * fld_sender,
    struct mailimf_reply_to * fld_reply_to,
    struct mailimf_to * fld_to,
    struct mailimf_cc * fld_cc,
    struct mailimf_bcc * fld_bcc,
    struct mailimf_message_id * fld_message_id,
    struct mailimf_in_reply_to * fld_in_reply_to,
    struct mailimf_references * fld_references,
    struct mailimf_subject * fld_subject,
    struct mailimf_comments * fld_comments,
    struct mailimf_keywords * fld_keywords,
    struct mailimf_optional_field * fld_optional_field);

void mailimf_field_free(struct mailimf_field * field);
        </PRE
><P
>          This is one header field of a message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>type</B
> is the type of the field. This define the
              type of the field.
              Only the corresponding field should be, then,
              filled. The value of this field can be one of :
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RETURN_PATH</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_DATE</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_FROM</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_SENDER</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_TO</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_CC</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_BCC</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_MSG_ID</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_ORIG_DATE</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_FROM</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_SENDER</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_REPLY_TO</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_TO</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_CC</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_BCC</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_MESSAGE_ID</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_IN_REPLY_TO</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_REFERENCES</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_SUBJECT</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_COMMENTS</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_KEYWORDS</B
>,
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_OPTIONAL_FIELD</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_return_path</B
> is the
              parsed content of the Return-Path field
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RETURN_PATH</B
>
              (see <A
HREF="#MAILIMF-RETURN"
>the Section called <I
>mailimf_return - parsed content of Return-Path field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_date</B
> is the
              parsed content of the Resent-Date field
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_DATE</B
>
              (see <A
HREF="#MAILIMF-ORIG-DATE"
>the Section called <I
>mailimf_orig_date - parsed content of date header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_from</B
> is the
              parsed content of the Resent-From field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_FROM</B
>
              (see <A
HREF="#MAILIMF-FROM"
>the Section called <I
>mailimf_from - parsed content of From header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_sender</B
> is the
              parsed content of the Resent-Sender field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_SENDER</B
>
              (see <A
HREF="#MAILIMF-SENDER"
>the Section called <I
>mailimf_sender - parsed content of Sender header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_to</B
> is the parsed
              content of the Resent-To field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_TO</B
>
              (see <A
HREF="#MAILIMF-TO"
>the Section called <I
>mailimf_to - parsed content of To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_cc</B
> is the parsed
              content of the Resent-Cc field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_CC</B
>
              (see <A
HREF="#MAILIMF-CC"
>the Section called <I
>mailimf_cc - parsed content of Cc</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_bcc</B
> is the parsed
              content of the Resent-Bcc field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_BCC</B
>
              (see <A
HREF="#MAILIMF-BCC"
>the Section called <I
>mailimf_bcc - parsed content of Bcc field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_resent_msg_id</B
> is the
              parsed content of the Resent-Message-ID field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_RESENT_MSG_ID</B
>
              (see <A
HREF="#MAILIMF-MESSAGE-ID"
>the Section called <I
>mailimf_message_id - parsed content of Message-ID header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_orig_date</B
> is the parsed
              content of the Date field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_ORIG_DATE</B
>
              (see <A
HREF="#MAILIMF-ORIG-DATE"
>the Section called <I
>mailimf_orig_date - parsed content of date header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_from</B
> is the parsed
              content of the From field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_FROM</B
>
              (see <A
HREF="#MAILIMF-FROM"
>the Section called <I
>mailimf_from - parsed content of From header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_sender</B
> is the parsed
              content of the Sender field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_SENDER</B
>
              (see <A
HREF="#MAILIMF-SENDER"
>the Section called <I
>mailimf_sender - parsed content of Sender header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_reply_to</B
> is the parsed
              content of the Reply-To field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_REPLY_TO</B
>
              (see <A
HREF="#MAILIMF-REPLY-TO"
>the Section called <I
>mailimf_reply_to - parsed content of Reply-To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_to</B
> is the parsed content
              of the To field if type is
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_TO</B
>
              (see <A
HREF="#MAILIMF-TO"
>the Section called <I
>mailimf_to - parsed content of To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_cc</B
> is the parsed content
              of the Cc field if type is
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_CC</B
>
              (see <A
HREF="#MAILIMF-CC"
>the Section called <I
>mailimf_cc - parsed content of Cc</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_bcc</B
> is the parsed
              content of the Bcc field if type is
              <B
CLASS="COMMAND"
>MAILIMF_FIELD_BCC</B
>
              (see <A
HREF="#MAILIMF-BCC"
>the Section called <I
>mailimf_bcc - parsed content of Bcc field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_message_id</B
> is the parsed
              content of the Message-ID field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_MESSAGE_ID</B
>
              (see <A
HREF="#MAILIMF-MESSAGE-ID"
>the Section called <I
>mailimf_message_id - parsed content of Message-ID header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_in_reply_to</B
> is the
              parsed content of the In-Reply-To field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_IN_REPLY_TO</B
>
              (see <A
HREF="#MAILIMF-IN-REPLY-TO"
>the Section called <I
>mailimf_in_reply_to - parsed content of In-Reply-To
        field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_references</B
> is the parsed
              content of the References field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_REFERENCES</B
>
              (see <A
HREF="#MAILIMF-REFERENCES"
>the Section called <I
>mailimf_references - parsed content of References field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_subject</B
> is the content
              of the Subject field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_SUBJECT</B
>
              (see <A
HREF="#MAILIMF-SUBJECT"
>the Section called <I
>mailimf_subject - parsed content of Subject field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_comments</B
> is the content of the
              Comments field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_COMMENTS</B
>
              (see <A
HREF="#MAILIMF-COMMENTS"
>the Section called <I
>mailimf_comments - parsed content of Comments field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_keywords</B
> is the parsed
              content of the Keywords field 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_KEYWORDS</B
>
              (see <A
HREF="#MAILIMF-KEYWORDS"
>the Section called <I
>mailimf_keywords - parsed content of Keywords field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_optional_field</B
> is an
              other field and is not parsed 
              if type is <B
CLASS="COMMAND"
>MAILIMF_FIELD_OPTIONAL_FIELD</B
>
              (see <A
HREF="#MAILIMF-OPTIONAL-FIELD"
>the Section called <I
>mailimf_optional_field - non-standard header</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_field_new()</B
> creates and
          initializes a data structure with a value. 
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_field_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN961"
></A
><P
><B
>Example 3-27. creation and display of field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_field * f;
  struct mailimf_mailbox * mb;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_from * from;
  
  /* build header 'From' */
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  
  f = mailimf_field_new(MAILIMF_FIELD_FROM,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    from, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);
  /* do the things */
  mailimf_field_free(f);

  return 0;
}

/* display content of the header */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_field(struct mailimf_field * field)
{
  switch (field-&gt;type) {
  case MAILIMF_FIELD_RETURN_PATH:
    printf("Return-Path:\n");
    display_return(field-&gt;fld_data.fld_return_path);
    break;
  case MAILIMF_FIELD_RESENT_DATE:
    printf("Resent-Date:\n");
    display_orig_date(field-&gt;fld_data.fld_orig_date);
    break;
  case MAILIMF_FIELD_RESENT_FROM:
    printf("Resent-From:\n");
    display_from(field-&gt;fld_data.fld_orig_date);
    break;
  case MAILIMF_FIELD_RESENT_SENDER:
    printf("Resent-Sender:\n");
    display_sender(field-&gt;fld_data.fld_resent_sender);
    break;
  case MAILIMF_FIELD_RESENT_TO:
    printf("Resent-To:\n");
    display_to(field-&gt;fld_data.fld_resent_to);
    break;
  case MAILIMF_FIELD_RESENT_CC:
    printf("Resent-Cc:\n");
    display_from(field-&gt;fld_data.fld_resent_cc);
    break;
  case MAILIMF_FIELD_RESENT_BCC:
    printf("Resent-Bcc:\n");
    display_from(field-&gt;fld_data.fld_resent_bcc);
    break;
  case MAILIMF_FIELD_RESENT_MSG_ID:
    printf("Resent-Message-ID:\n");
    display_message_id(field-&gt;fld_data.fld_resent_msg_id);
    break;
  case MAILIMF_FIELD_ORIG_DATE:
    printf("Date:\n");
    display_orig_date(field-&gt;fld_data.fld_orig_date);
    break;
  case MAILIMF_FIELD_FROM:
    printf("From:\n");
    display_from(field-&gt;fld_data.fld_from);
    break;
  case MAILIMF_FIELD_SENDER:
    printf("Sender:\n");
     display_sender(field-&gt;fld_data.fld_sender);
    break;
  case MAILIMF_FIELD_REPLY_TO:
    printf("Reply-To:\n");
    display_reply_to(field-&gt;fld_data.fld_reply_to);
    break;
  case MAILIMF_FIELD_TO:
    printf("To:\n");
    display_to(field-&gt;fld_data.fld_to);
    break;
  case MAILIMF_FIELD_CC:
    printf("Cc:\n");
    display_cc(field-&gt;fld_data.fld_cc);
    break;
  case MAILIMF_FIELD_BCC:
    printf("Bcc:\n");
    display_bcc(field-&gt;fld_data.fld_bcc);
    break;
  case MAILIMF_FIELD_MESSAGE_ID:
    printf("Message-ID:\n");
    display_message_id(field-&gt;fld_data.fld_message_id);
    break;
  case MAILIMF_FIELD_IN_REPLY_TO:
    printf("In-Reply-To:\n");
    display_in_reply_to(field-&gt;fld_data.fld_in_reply_to);
    break;
  case MAILIMF_FIELD_REFERENCES:
    printf("References:\n");
    display_references(field-&gt;fld_data.fld_references_to);
    break;
  case MAILIMF_FIELD_SUBJECT:
    printf("Subject:\n");
    display_subject(field-&gt;fld_data.fld_subject);
    break;
  case MAILIMF_FIELD_COMMENTS:
    printf("Comments:\n");
    display_comments(field-&gt;fld_data.fld_comments);
    break;
  case MAILIMF_FIELD_KEYWORDS:
    printf("Keywords:\n");
    display_keywords(field-&gt;fld_data.fld_keywords);
    break;
  case MAILIMF_FIELD_OPTIONAL_FIELD:
    printf("[optional field]:\n");
    display_optional_field(field-&gt;fld_data.fld_optional_field);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FIELDS"
>mailimf_fields - list of header fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_fields {
  clist * fld_list; /* list of (struct mailimf_field *), != NULL */
};

struct mailimf_fields * mailimf_fields_new(clist * fld_list);

void mailimf_fields_free(struct mailimf_fields * fields);
        </PRE
><P
>          This is the list of header fields of a message.
        </P
><P
>          <B
CLASS="COMMAND"
>fld_list</B
> is a list of header fields. This
          is a <B
CLASS="COMMAND"
>clist</B
> which elements are 
          of type <B
CLASS="COMMAND"
>mailimf_field</B
> (see <A
HREF="#MAILIMF-FIELD"
>the Section called <I
>mailimf_field - header field</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN977"
></A
><P
><B
>Example 3-28. creation and display of header fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  struct mailimf_field * f;
  clist * list;
  struct mailimf_from * from;
  struct mailimf_to * to
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_address_list * addr_list;
  clist * fields_list;

  /* build headers */

  fields_list = clist_new();
  
  /* build header 'From' */
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  
  f = mailimf_field_new(MAILIMF_FIELD_FROM,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    from, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);

  clist_append(fields_list, f);
  
  /* build header To */

  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  addr_list = mailimf_address_list_new(list);
  
  to = mailimf_to_new(addr_list);

  f = mailimf_field_new(MAILIMF_FIELD_TO,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, to, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);
  
  clist_append(fields_list, f);
  
  fields = mailimf_fields_new(fields_list);
  /* do the things */
  mailimf_fields_free(fields);
  
  return 0;
}

/* display list of headers */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_fields(struct mailimf_fields * fields)
{
  clistiter * cur;

  for(cur = clist_begin(field-&gt;fld_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailimf_field * f;
    
    f = clist_content(cur);
    
    display_field(f);
    printf("\n");
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-BODY"
>mailimf_body - message body without headers</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_body {
  const char * bd_text; /* != NULL */
  size_t bd_size;
};

struct mailimf_body * mailimf_body_new(const char * bd_text, size_t bd_size);

void mailimf_body_free(struct mailimf_body * body);
        </PRE
><P
>          This is the text content of a message (without headers).
        </P
><P
>          <P
></P
><UL
><LI
><P
>                <B
CLASS="COMMAND"
>bd_text</B
> is the beginning of the
                text part, it is a substring of an other string.
                It is not necessarily zero terminated.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>bd_size</B
> is the size of the text part
              </P
></LI
></UL
>
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_body_new()</B
> creates and
          initializes a data structure with a value.
          Text given as argument will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_body_free()</B
> frees memory used by
          the structure.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN997"
></A
><P
><B
>Example 3-29. creation and display of message body</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_body * b;
  
  b = mailimf_body_new("this is the content of the message", 34);
  /* do the things */
  mailimf_body_free(b);
  
  return 0;
}

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_body(struct mailimf_body * b)
{
  char * text;

  text = malloc(b-&gt;size + 1);
  strncpy(text, b-&gt;bd_text, b-&gt;bd_size);
  text[b-&gt;size] = 0;

  puts(text);
  printf("\n");

  free(text);
    
  return 0;
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MESSAGE"
>mailimf_message - parsed message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_message {
  struct mailimf_fields * msg_fields; /* != NULL */
  struct mailimf_body * msg_body;     /* != NULL */
};

struct mailimf_message *
mailimf_message_new(struct mailimf_fields * msg_fields,
    struct mailimf_body * msg_body);

void mailimf_message_free(struct mailimf_message * message);
        </PRE
><P
>          This is the message content (text and headers).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fields</B
> is the header fields of
              the message
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_body</B
> is the text part of the message
              (see <A
HREF="#MAILIMF-BODY"
>the Section called <I
>mailimf_body - message body without headers</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_message_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_message_free()</B
> frees memory used
          by the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1017"
></A
><P
><B
>Example 3-30. creation and display of message</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_body * b;
  struct mailimf_message * m;
  struct mailimf_fields * fields;
  struct mailimf_fields * f;
  clist * list;
  struct mailimf_from * from;
  struct mailimf_to * to
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_address_list * addr_list;
  clist * fields_list;

  /* build text content */
  
  b = mailimf_body_new("this is the content of the message", 34);
  
  /* build headers */

  fields_list = clist_new();
  
  /* build header 'From' */
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  
  f = mailimf_field_new(MAILIMF_FIELD_FROM,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    from, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);

  clist_append(fields_list, f);
  
  /* build header To */

  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  addr_list = mailimf_address_list_new(list);
  
  to = mailimf_to_new(addr_list);

  f = mailimf_field_new(MAILIMF_FIELD_TO,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, to, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);
  
  clist_append(fields_list, f);
  
  fields = mailimf_fields_new(fields_list);

  /* build message */
  
  m = mailimf_message_new(fields, b);
  /* do the things */
  mailimf_message_free(m);
  
  return 0;
}

/* display the message */

#include &lt;libetpan/libetpan.h&gt;
#include &lt;stdio.h&gt;

void display_message(struct mailimf_message * msg)
{
  display_fields(msg-&gt;msg_fields);
  printf("\n");
  display_body(msg-&gt;msg_body);
  printf("\n");
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-SINGLE-FIELDS"
>mailimf_single_fields - simplified fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_single_fields {
  struct mailimf_orig_date * fld_orig_date;      /* can be NULL */
  struct mailimf_from * fld_from;                /* can be NULL */
  struct mailimf_sender * fld_sender;            /* can be NULL */
  struct mailimf_reply_to * fld_reply_to;        /* can be NULL */
  struct mailimf_to * fld_to;                    /* can be NULL */
  struct mailimf_cc * fld_cc;                    /* can be NULL */
  struct mailimf_bcc * fld_bcc;                  /* can be NULL */
  struct mailimf_message_id * fld_message_id;    /* can be NULL */
  struct mailimf_in_reply_to * fld_in_reply_to;  /* can be NULL */
  struct mailimf_references * fld_references;    /* can be NULL */
  struct mailimf_subject * fld_subject;          /* can be NULL */
  struct mailimf_comments * fld_comments;        /* can be NULL */
  struct mailimf_keywords * fld_keywords;        /* can be NULL */
};

struct mailimf_single_fields *
mailimf_single_fields_new(struct mailimf_fields * fields);

void mailimf_single_fields_free(struct mailimf_single_fields *
                                single_fields);

void mailimf_single_fields_init(struct mailimf_single_fields * single_fields,
                                struct mailimf_fields * fields);</PRE
><P
>          Structure that contains some standard fields and allows access
          to a given header without running through the list.
        </P
><P
>          mailimf_fields is the native structure that IMF module will use,
          this module will provide an easier structure to use when
          parsing fields.
          mailimf_single_fields is an easier structure to get parsed fields,
          rather than iteration over the list of fields
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_orig_date</B
> is the parsed "Date"
              field
              (see <A
HREF="#MAILIMF-ORIG-DATE"
>the Section called <I
>mailimf_orig_date - parsed content of date header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_from</B
> is the parsed "From" field
              (see <A
HREF="#MAILIMF-FROM"
>the Section called <I
>mailimf_from - parsed content of From header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_sender</B
> is the parsed "Sender "field
              (see <A
HREF="#MAILIMF-SENDER"
>the Section called <I
>mailimf_sender - parsed content of Sender header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>reply_to</B
> is the parsed "Reply-To" field
              (see <A
HREF="#MAILIMF-REPLY-TO"
>the Section called <I
>mailimf_reply_to - parsed content of Reply-To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_to</B
> is the parsed "To" field
              (see <A
HREF="#MAILIMF-TO"
>the Section called <I
>mailimf_to - parsed content of To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_cc</B
> is the parsed "Cc" field
              (see <A
HREF="#MAILIMF-CC"
>the Section called <I
>mailimf_cc - parsed content of Cc</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_bcc</B
> is the parsed "Bcc" field
              (see <A
HREF="#MAILIMF-BCC"
>the Section called <I
>mailimf_bcc - parsed content of Bcc field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_message_id</B
> is the parsed
              "Message-ID" field.
              (see <A
HREF="#MAILIMF-MESSAGE-ID"
>the Section called <I
>mailimf_message_id - parsed content of Message-ID header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_in_reply_to</B
> is the parsed
              "In-Reply-To" field.
              (see <A
HREF="#MAILIMF-IN-REPLY-TO"
>the Section called <I
>mailimf_in_reply_to - parsed content of In-Reply-To
        field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_references</B
> is the parsed
              "References" field.
              (see <A
HREF="#MAILIMF-REFERENCES"
>the Section called <I
>mailimf_references - parsed content of References field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_subject</B
> is the parsed "Subject" field
              (see <A
HREF="#MAILIMF-SUBJECT"
>the Section called <I
>mailimf_subject - parsed content of Subject field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_comments</B
> is the parsed "Comments" field
              (see <A
HREF="#MAILIMF-COMMENTS"
>the Section called <I
>mailimf_comments - parsed content of Comments field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_keywords</B
> is the parsed "Keywords" field
              (see <A
HREF="#MAILIMF-KEYWORDS"
>the Section called <I
>mailimf_keywords - parsed content of Keywords field</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_single_fields_new()</B
> creates and
          initializes a data structure with a value.
          Structures given as argument are referenced by the created
          object and will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be freed if the
          object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_single_fields_free()</B
> frees memory
          used by the structure and 
          substructures will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be
          released. They should be released by the application.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_single_fields_init()</B
> will
          initialize fill the data structure, using
          the given argument (<B
CLASS="COMMAND"
>fields</B
>). The
          interesting fields will be filled into
          <B
CLASS="COMMAND"
>single_fields</B
>.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1088"
></A
><P
><B
>Example 3-31. using mailimf_single_fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_single_fields * single_fields;
  struct mailimf_fields * fields;
  struct mailimf_field * f;
  clist * list;
  struct mailimf_from * from;
  struct mailimf_to * to
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_address_list * addr_list;
  clist * fields_list;

  /* build headers */

  fields_list = clist_new();
  
  /* build header 'From' */
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  
  f = mailimf_field_new(MAILIMF_FIELD_FROM,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    from, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);

  clist_append(fields_list, f);
  
  /* build header To */

  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  addr_list = mailimf_address_list_new(list);
  
  to = mailimf_to_new(addr_list);

  f = mailimf_field_new(MAILIMF_FIELD_TO,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, to, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);
  
  clist_append(fields_list, f);
  
  fields = mailimf_fields_new(fields_list);
  
  /* create the single fields */
  single_fields = mailimf_single_fields_new(fields);
  /* do the things */
  mailimf_single_fields_free(single_fields);
  mailimf_fields_free(fields);
  
  return 0;
}
          </PRE
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1091"
></A
><P
><B
>Example 3-32. using mailimf_single_fields without memory allocation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_single_fields single_fields;
  struct mailimf_fields * fields;
  struct mailimf_field * f;
  clist * list;
  struct mailimf_from * from;
  struct mailimf_to * to
  struct mailimf_mailbox * mb;
  struct mailimf_address * addr;
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_address_list * addr_list;
  clist * fields_list;

  /* build headers */

  fields_list = clist_new();
  
  /* build header 'From' */
  
  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  clist_append(list, mb);
  mb_list = mailimf_mailbox_list_new(list);
  
  from = mailimf_from_new(mb_list);
  
  f = mailimf_field_new(MAILIMF_FIELD_FROM,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    from, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);

  clist_append(fields_list, f);
  
  /* build header To */

  list = clist_new();
  mb = mailimf_mailbox_new(strdup("DINH =?iso-8859-1?Q?Vi=EAt_Ho=E0?="),
    strdup("dinh.viet.hoa@free.fr"));
  addr = mailimf_address_new(MAILIMF_ADDRESS_MAILBOX, mb, NULL);
  clist_append(list, addr);
  addr_list = mailimf_address_list_new(list);
  
  to = mailimf_to_new(addr_list);

  f = mailimf_field_new(MAILIMF_FIELD_TO,
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, to, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, NULL, NULL);
  
  clist_append(fields_list, f);
  
  fields = mailimf_fields_new(fields_list);
  
  /* fill the single fields */
  mailimf_fields_fields_init(&amp;single_fields, fields);
  /* do the things */
  mailimf_fields_free(fields);
  
  return 0;
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1094"
>Parser functions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ADDRESS-LIST-PARSE"
>mailimf_address_list_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int
mailimf_address_list_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_address_list ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_parse()</B
> parse a list
          of addresses  in RFC 2822 form.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing
              the list of addresses.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> this is a pointer to the
              start of the list of 
              addresses in the given string,
              <B
CLASS="COMMAND"
>(* index)</B
> is modified to point
              at the end of the parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-ADDRESS-LIST"
>the Section called <I
>mailimf_address_list - list of addresses</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1120"
></A
><P
><B
>Example 3-33. parsing a list of addresses</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_address_list * addr_list;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_address_list_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;addr_list);
	if (r == MAILIMF_NO_ERROR) {
	    display_address_list(addr_list);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_address_list_free(addr_list);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ADDRESS-PARSE"
>mailimf_address_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailimf_address_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_address ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_address_parse()</B
> parse an address
          in RFC 2822 form.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the
              address.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse operation
              is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-ADDRESS"
>the Section called <I
>mailimf_address - address</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1147"
></A
><P
><B
>Example 3-34. parsing an address</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_address * addr;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_address_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;addr);
	if (r == MAILIMF_NO_ERROR) {
	    display_address(addr);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_address_free(addr);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-BODY-PARSE"
>mailimf_body_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_body_parse(char * message, size_t length,
		       size_t * index,
		       struct mailimf_body ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_body_parse()</B
> parse text body of a
          message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing
              the message body part.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> this is a pointer to the start
              of the message text part in
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end
              of the parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in 
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-BODY"
>the Section called <I
>mailimf_body - message body without headers</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1174"
></A
><P
><B
>Example 3-35. parsing a message body</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;

  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_body * b;
        struct mailimf_fields * f;
	size_t current_index;        
	size_t size;
	
	size = stat_info.st_size;
	current_index = 0;
	r = mailimf_fields_parse(mem, size, &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {	
	  r = mailimf_crlf_parse(mem, size, &amp;current_index);
	  /* ignore parse error of crlf */
	  
	  r = mailimf_body_parse(mem, size, &amp;current_index, &amp;b);
	  if (r == MAILIMF_NO_ERROR) {
	    
	    display_body(b);
	    /* do the things */
	    status = EXIT_SUCCESS;
	    mailimf_body_free(b);
	  }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ENVELOPE-AND-OPTIONAL-FIELDS-PARSE"
>mailimf_envelope_and_optional_fields_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailimf_envelope_and_optional_fields_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_fields ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_envelope_and_optional_fields_parse()</B
>
          returns a list of most useful headers (parsed). The other
          headers will be placed in the list in a non-parsed form.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the header.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>          <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the header in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end 
              of the parsed data
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1201"
></A
><P
><B
>Example 3-36. parsing commonly used fields and return other fields
          in a non-parsed form</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_envelope_and_optional_fields_parse(mem, stat_info.st_size,
            &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
	    display_fields(m);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ENVELOPE-FIELDS-PARSE"
>mailimf_envelope_fields_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_envelope_fields_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_fields ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_envelope_fields_parse()</B
> return a
          list of most useful headers (parsed).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the header
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the header in 
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end 
              of the parsed data
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1228"
></A
><P
><B
>Example 3-37. parsing commonly used fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_envelope_fields_parse(mem, stat_info.st_size,
            &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
	    display_fields(m);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-OPTIONAL-FIELDS-PARSE"
>mailimf_optional_fields_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailimf_optional_fields_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_fields ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_optional_fields_parse</B
> return a
          list of non-parsed headers.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the header
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the header in 
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end 
              of the parsed data
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1255"
></A
><P
><B
>Example 3-38. parsing optional fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_optional_fields_parse(mem, stat_info.st_size,
            &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
	    display_fields(m);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FIELDS-PARSE"
>mailimf_fields_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_fields_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_fields ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_parse()</B
> parse headers of a
          message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the header
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the header in 
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end 
              of the parsed data
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1282"
></A
><P
><B
>Example 3-39. parsing header fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
	    display_fields(f);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
            </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-IGNORE-FIELD-PARSE"
>mailimf_ignore_field_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_ignore_field_parse(char * message, size_t length,
    size_t * index);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_ignore_field_parse()</B
> skip the
          next header.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the header
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given string
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the field to skip in 
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end 
              of the parsed data
            </P
></LI
></UL
><P
>          return <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
> on success,
          <B
CLASS="COMMAND"
>MAILIMF_ERROR_XXX</B
> on error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1304"
></A
><P
><B
>Example 3-40. skipping fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_ignore_field_parse(mem, stat_info.st_size,
            &amp;current_index);
	if (r == MAILIMF_NO_ERROR) {
	  /* do the things */
	  status = EXIT_SUCCESS;
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MAILBOX-LIST-PARSE"
>mailimf_mailbox_list_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailimf_mailbox_list_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_mailbox_list ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_parse()</B
> parse a list
          of mailboxes in RFC 2822 form.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the
              list of mailboxes.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given
              string.
            </P
></LI
><LI
><P
>          <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the list of
              mailboxes in the given string,
              <B
CLASS="COMMAND"
>(* index)</B
> is modified to point 
              at the end of the parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in 
              <B
CLASS="COMMAND"
>(* result)</B
>.
              (see <A
HREF="#MAILIMF-MAILBOX-LIST"
>the Section called <I
>mailimf_mailbox_list - list of mailboxes</I
></A
>)
            </P
></LI
></UL
><P
>          return MAILIMF_NO_ERROR on success, MAILIMF_ERROR_XXX on
          error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1329"
></A
><P
><B
>Example 3-41. parsing a list of mailboxes</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_mailbox_list * mb_list;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_mailbox_list_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;mb_list);
	if (r == MAILIMF_NO_ERROR) {
	    display_mailbox_list(mb_list);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_mailbox_list_free(mb_list);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MAILBOX-PARSE"
>mailimf_mailbox_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>        
#include &lt;libetpan/libetpan.h&gt;

int mailimf_mailbox_parse(char * message, size_t length,
    size_t * index,
    struct mailimf_mailbox ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_parse</B
> parse a mailbox in
          RFC 2822 form.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing the
              mailbox.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> this is the size of the given
              string.
            </P
></LI
><LI
><P
>          <B
CLASS="COMMAND"
>index</B
> index this is a pointer to the
              start of the mailbox in the given string,
              <B
CLASS="COMMAND"
>(* index)</B
> is modified to point 
              at the end of the parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
> the result of the parse
              operation is stored in 
              <B
CLASS="COMMAND"
>(* result)</B
>.
              (see <A
HREF="#MAILIMF-MAILBOX"
>the Section called <I
>mailimf_mailbox - mailbox</I
></A
>)
            </P
></LI
></UL
><P
>          return MAILIMF_NO_ERROR on success, MAILIMF_ERROR_XXX on
          error.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1354"
></A
><P
><B
>Example 3-42. parsing a mailbox</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_mailbox_list * mb_list;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_mailbox_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;mb_list);
	if (r == MAILIMF_NO_ERROR) {
	    display_mailbox_list(mb_list);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_mailbox_free(mb_list);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MESSAGE-PARSE"
>mailimf_message_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_message_parse(char * message, size_t length,
			  size_t * index,
			  struct mailimf_message ** result);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_message_parse</B
> parse message
          (headers and body).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> this is a string containing
              the message content.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>param</B
> length this is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>param</B
> index this is a pointer to the
              start of the message in
              the given string, <B
CLASS="COMMAND"
>(* index)</B
> is
              modified to point at the end 
              of the parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>param</B
> result the result of the parse
              operation is stored in
              <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILIMF-MESSAGE"
>the Section called <I
>mailimf_message - parsed message</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1378"
></A
><P
><B
>Example 3-43. parsing a message</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;  
  int r;

  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &#62;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &#62;= 0) {     
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_message * m;
	size_t current_index;        
	
	current_index = 0;
	r = mailimf_message_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;m);
	if (r == MAILIMF_NO_ERROR) {
	    display_message(m);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailimf_message_free(m);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1381"
>Creation functions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILIMF-MAILBOX-LIST-ADD"
>mailimf_mailbox_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_mailbox_list *
mailimf_mailbox_list_new_empty();

int mailimf_mailbox_list_add(struct mailimf_mailbox_list * mailbox_list,
			     struct mailimf_mailbox * mb);

int mailimf_mailbox_list_add_parse(struct mailimf_mailbox_list * mailbox_list,
				   char * mb_str);

int mailimf_mailbox_list_add_mb(struct mailimf_mailbox_list * mailbox_list,
				char * display_name, char * address);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_new_empty()</B
> creates a
          new empty list of mailboxes.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_add</B
> adds a mailbox
          to the list of mailboxes.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_add_parse</B
> adds a
          mailbox given in form of a string to the list of mailboxes.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_mailbox_list_add_mb</B
> adds a
          mailbox given in form of a couple : display name, mailbox
          address.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>mailbox_list</B
> is the list of mailboxes.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mb</B
> is a mailbox
              (see <A
HREF="#MAILIMF-MAILBOX"
>the Section called <I
>mailimf_mailbox - mailbox</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mb_str</B
> is a mailbox given in the form
              of a string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>display_name</B
> is the display name.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>address</B
> is the mailbox address.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1411"
></A
><P
><B
>Example 3-44. creating a list of mailboxes</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_mailbox_list * mb_list;
  struct mailimf_mailbox * mb;

  mb_list = mailimf_mailbox_list_new_empty();

  mb = mailimf_mailbox_new(strdup("DINH Viet Hoa"),
    strdup("dinh.viet.hoa@free.fr"));
  mailimf_mailbox_list_add(mb_list, mb);

  mailimf_mailbox_list_add_parse(mb_list, "foo bar &lt;foo@bar.org&gt;");

  mailimf_mailbox_list_add_mb(mb_list, strdup("bar foo"), strdup("bar@foo.com"));

  mailimf_mailbox_list_free(mb_list);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-ADDRESS-LIST-ADD"
>mailimf_address_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_address_list * mailimf_address_list_new_empty();

int mailimf_address_list_add(struct mailimf_address_list * address_list,
			     struct mailimf_address * addr);

int mailimf_address_list_add_parse(struct mailimf_address_list * address_list,
				   char * addr_str);

int mailimf_address_list_add_mb(struct mailimf_address_list * address_list,
				char * display_name, char * address);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_new_empty()</B
> creates a
          new empty list of addresses.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_add</B
> adds an address
          to the list of addresses.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_add_parse</B
> adds an
          address given in form of a string to the list of addresses.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_address_list_add_mb</B
> adds a
          mailbox given in form of a couple : display name, mailbox
          address.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>address_list</B
> is the list of mailboxes.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>addr</B
> is an address.
              (see <A
HREF="#MAILIMF-ADDRESS"
>the Section called <I
>mailimf_address - address</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>addr_str</B
> is an address given in the form of a
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>display_name</B
> is the display name.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>address</B
> is the mailbox address.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FIELDS-ADD"
>mailimf_fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailimf_fields *
mailimf_fields_new_empty(void);

struct mailimf_field * mailimf_field_new_custom(char * name, char * value);

int mailimf_fields_add(struct mailimf_fields * fields,
		       struct mailimf_field * field);

int mailimf_fields_add_data(struct mailimf_fields * fields,
			    struct mailimf_date_time * date,
			    struct mailimf_mailbox_list * from,
			    struct mailimf_mailbox * sender,
			    struct mailimf_address_list * reply_to,
			    struct mailimf_address_list * to,
			    struct mailimf_address_list * cc,
			    struct mailimf_address_list * bcc,
			    char * msg_id,
			    clist * in_reply_to,
			    clist * references,
			    char * subject);

struct mailimf_fields *
mailimf_fields_new_with_data_all(struct mailimf_date_time * date,
				 struct mailimf_mailbox_list * from,
				 struct mailimf_mailbox * sender,
				 struct mailimf_address_list * reply_to,
				 struct mailimf_address_list * to,
				 struct mailimf_address_list * cc,
				 struct mailimf_address_list * bcc,
				 char * message_id,
				 clist * in_reply_to,
				 clist * references,
				 char * subject);

struct mailimf_fields *
mailimf_fields_new_with_data(struct mailimf_mailbox_list * from,
			     struct mailimf_mailbox * sender,
			     struct mailimf_address_list * reply_to,
			     struct mailimf_address_list * to,
			     struct mailimf_address_list * cc,
			     struct mailimf_address_list * bcc,
			     clist * in_reply_to,
			     clist * references,
			     char * subject);

char * mailimf_get_message_id(void);

struct mailimf_date_time * mailimf_get_current_date(void);

int
mailimf_resent_fields_add_data(struct mailimf_fields * fields,
    struct mailimf_date_time * resent_date,
    struct mailimf_mailbox_list * resent_from,
    struct mailimf_mailbox * resent_sender,
    struct mailimf_address_list * resent_to,
    struct mailimf_address_list * resent_cc,
    struct mailimf_address_list * resent_bcc,
    char * resent_msg_id);

struct mailimf_fields *
mailimf_resent_fields_new_with_data_all(struct mailimf_date_time *
    resent_date, struct mailimf_mailbox_list * resent_from,
    struct mailimf_mailbox * resent_sender,
    struct mailimf_address_list * resent_to,
    struct mailimf_address_list * resent_cc,
    struct mailimf_address_list * resent_bcc,
    char * resent_msg_id);

struct mailimf_fields *
mailimf_resent_fields_new_with_data(struct mailimf_mailbox_list * from,
    struct mailimf_mailbox * resent_sender,
    struct mailimf_address_list * resent_to,
    struct mailimf_address_list * resent_cc,
    struct mailimf_address_list * resent_bcc);
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>from</B
> is the parsed content of the
              From field
              (see <A
HREF="#MAILIMF-FROM"
>the Section called <I
>mailimf_from - parsed content of From header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sender</B
> is the parsed content of the
              Sender field
              (see <A
HREF="#MAILIMF-SENDER"
>the Section called <I
>mailimf_sender - parsed content of Sender header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>reply_to</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Reply-To</B
> field 
              (see <A
HREF="#MAILIMF-REPLY-TO"
>the Section called <I
>mailimf_reply_to - parsed content of Reply-To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>to</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>To</B
> field 
              (see <A
HREF="#MAILIMF-TO"
>the Section called <I
>mailimf_to - parsed content of To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>cc</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Cc</B
> field 
              (see <A
HREF="#MAILIMF-CC"
>the Section called <I
>mailimf_cc - parsed content of Cc</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>bcc</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Bcc</B
> field 
              (see <A
HREF="#MAILIMF-BCC"
>the Section called <I
>mailimf_bcc - parsed content of Bcc field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>message_id</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>Message-ID</B
> field 
              (see <A
HREF="#MAILIMF-MESSAGE-ID"
>the Section called <I
>mailimf_message_id - parsed content of Message-ID header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>in_reply_to</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>In-Reply-To</B
> field 
              (see <A
HREF="#MAILIMF-IN-REPLY-TO"
>the Section called <I
>mailimf_in_reply_to - parsed content of In-Reply-To
        field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>references</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>References</B
> field 
              (see <A
HREF="#MAILIMF-REFERENCES"
>the Section called <I
>mailimf_references - parsed content of References field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>subject</B
> is the content of the
              <B
CLASS="COMMAND"
>Subject</B
> field
              (see <A
HREF="#MAILIMF-SUBJECT"
>the Section called <I
>mailimf_subject - parsed content of Subject field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_date</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>Resent-Date</B
> field
              (see <A
HREF="#MAILIMF-ORIG-DATE"
>the Section called <I
>mailimf_orig_date - parsed content of date header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_from</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>Resent-From</B
> field 
              (see <A
HREF="#MAILIMF-FROM"
>the Section called <I
>mailimf_from - parsed content of From header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_sender</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Resent-Sender</B
> field
              (see <A
HREF="#MAILIMF-SENDER"
>the Section called <I
>mailimf_sender - parsed content of Sender header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_to</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>Resent-To</B
> field
              (see <A
HREF="#MAILIMF-TO"
>the Section called <I
>mailimf_to - parsed content of To header</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_cc</B
> is the parsed content of
              the <B
CLASS="COMMAND"
>Resent-Cc</B
> field
              (see <A
HREF="#MAILIMF-CC"
>the Section called <I
>mailimf_cc - parsed content of Cc</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_bcc</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Resent-Bcc</B
> field
              (see <A
HREF="#MAILIMF-BCC"
>the Section called <I
>mailimf_bcc - parsed content of Bcc field</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>resent_msg_id</B
> is the parsed content of the
              <B
CLASS="COMMAND"
>Resent-Message-ID</B
> field
              (see <A
HREF="#MAILIMF-MESSAGE-ID"
>the Section called <I
>mailimf_message_id - parsed content of Message-ID header</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_new_empty()</B
> creates a new
          empty set of headers.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_field_new_custom()</B
> creates a new
          custom header.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_add()</B
> adds a header to the
          set of headers.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_add_data()</B
> adds some headers
          to the set of headers.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_new_with_data_all()</B
> creates
          a set of headers with some headers (including Date and
          Message-ID).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_new_with_data()</B
> creates a
          set of headers with some headers (Date and Message-ID will
          be generated).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_get_message_id()</B
> generates a
          Message-ID. The result must be freed using
          <B
CLASS="COMMAND"
>free()</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_get_current_date()</B
> generates a
          Date. The result must be freed using 
          <B
CLASS="COMMAND"
>mailimf_date_time_free</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_resent_fields_add_data()</B
> adds some
          resent headers to the set of headers.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_resent_fields_new_with_data_all()</B
>
          creates a set of headers with some resent headers (including
          Resent-Date and Resent-Message-ID).
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_resent_fields_new_with_data()</B
>
          creates a set of headers with some resent headers
          (Resent-Date and Resent-Message-ID will be generated)
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1553"
></A
><P
><B
>Example 3-45. creation of header fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  struct mailimf_field * field;
  struct mailimf_date_time * date;
  char * msg_id;
  struct mailimf_mailbox_list * from;
  struct mailimf_address_list * to;

  fields = mailimf_fields_new_empty();
  field = mailimf_field_new_custom(strdup("X-Mailer"), strdup("my-mailer"));
  mailimf_fields_add(fields, field);

  from = mailimf_mailbox_list_new_empty();
  mailimf_mailbox_list_add_mb(from, strdup("DINH Viet Hoa"), strdup("dinh.viet.hoa@free.fr");
  date = mailimf_get_current_date();
  msg_id = mailimf_get_message_id();
  to = mailimf_address_list_new_empty();
  mailimf_address_list_add_mb(to, strdup("FOO Bar"), strdup("foo@bar.org");

  mailimf_fields_add_data(fields, date, from, NULL, NULL, to, NULL, NULL,
    msg_id, NULL, NULL, strdup("hello"));

  /* do the things */

  mailimf_fields_free(fields);
}

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  struct mailimf_mailbox_list * from;
  struct mailimf_address_list * to;
  struct mailimf_date_time * date;
  char * msg_id;

  from = mailimf_mailbox_list_new_empty();
  mailimf_mailbox_list_add_mb(from, strdup("DINH Viet Hoa"), strdup("dinh.viet.hoa@free.fr");
  to = mailimf_address_list_new_empty();
  mailimf_address_list_add_mb(to, strdup("FOO Bar"), strdup("foo@bar.org");
  date = mailimf_get_current_date();
  msg_id = mailimf_get_message_id();

  fields = mailimf_fields_new_with_all_data(date, from, NULL, NULL, to, NULL, NULL,
    msg_id, NULL, NULL, strdup("hello"));

  /* do the things */

  mailimf_fields_free(fields);
}

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  struct mailimf_mailbox_list * from;
  struct mailimf_address_list * to;

  from = mailimf_mailbox_list_new_empty();
  mailimf_mailbox_list_add_mb(from, strdup("DINH Viet Hoa"), strdup("dinh.viet.hoa@free.fr");
  to = mailimf_address_list_new_empty();
  mailimf_address_list_add_mb(to, strdup("FOO Bar"), strdup("foo@bar.org");

  fields = mailimf_fields_new_with_data(from, NULL, NULL, to, NULL, NULL,
    NULL, NULL, strdup("hello"));

  /* do the things */

  mailimf_fields_free(fields);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1556"
>Rendering of messages</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILIMF-FIELDS-WRITE"
>Header fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailimf_fields_write(FILE * f, int * col,
    struct mailimf_fields * fields);

int mailimf_envelope_fields_write(FILE * f, int * col,
    struct mailimf_fields * fields);

int mailimf_field_write(FILE * f, int * col,
    struct mailimf_field * field);
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>col</B
> current column is given for wrapping
              purpose in <B
CLASS="COMMAND"
>(* col)</B
>,
              the resulting columns will be returned..
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>f</B
> is the file descriptor. It can be
              stdout for example.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
> is the header fields
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>field</B
> is a field
              (see <A
HREF="#MAILIMF-FIELD"
>the Section called <I
>mailimf_field - header field</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailimf_fields_write</B
> outputs the set of
          header fields.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_envelope_fields_write</B
> outputs the
          set of header fields except the optional fields.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_field_write</B
> outputs a header.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1583"
></A
><P
><B
>Example 3-46. rendering of fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  int col;

  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_imf_fields();

  col = 0;
  mailimf_fields_write(stdout, &amp;col, fields);

  mailimf_fields_free(fields);
}

int main(int argc, char ** argv)
{
  struct mailimf_fields * fields;
  int col;

  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_imf_fields();

  col = 0;
  mailimf_envelope_fields_write(stdout, &amp;col, fields);

  mailimf_fields_free(fields);
}

int main(int argc, char ** argv)
{
  struct mailimf_field * field;
  int col;

  field = mailimf_field_new_custom(strdup("X-Mailer"), strdup("my mailer"));

  col = 0;
  mailimf_field_write(stdout, &amp;col, field);

  mailimf_field_free(field);
}
          </PRE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1586"
></A
>Chapter 4. MIME</H1
><P
>      libEtPan! implements a MIME message parser (also known as
      messages with attachments or 
      multipart messages). This also allows to generate MIME messages.
    </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>        All allocation functions will take as argument allocated data
        and will store these data in the structure they will allocate.
        Data should be persistant during all the use of the structure
        and will be freed by the free function of the structure
      </P
><P
>        allocation functions will return <B
CLASS="COMMAND"
>NULL</B
> on failure

        functions returning integer will be returning one of the
        following error code:
        <B
CLASS="COMMAND"
>MAILIMF_NO_ERROR</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_PARSE</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_MEMORY</B
>,
        <B
CLASS="COMMAND"
>MAILIMF_ERROR_INVAL</B
>,
        or <B
CLASS="COMMAND"
>MAILIMF_ERROR_FILE</B
>.
      </P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1598"
>Quick start</A
></H2
><P
>        You will need this module when you want to parse a MIME
        message.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1601"
>Parse MIME message</A
></H3
><P
>          You will use the following function :
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>mailmime_parse</B
>
              (<A
HREF="#MAILIMF-ENVELOPE-AND-OPTIONAL-FIELDS-PARSE"
>the Section called <I
>mailimf_envelope_and_optional_fields_parse</I
> in Chapter 3</A
>)
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1609"
>Render the MIME message</A
></H3
><P
>        Build your MIME message, then use
        <B
CLASS="COMMAND"
>mailmime_write</B
>
        (<A
HREF="#MAILMIME-WRITE"
>the Section called <I
>mailmime_write</I
></A
>)
        to render a MIME message.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1614"
>Data types</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMIME-COMPOSITE-TYPE"
>mailmime_composite_type - Composite MIME type</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_COMPOSITE_TYPE_ERROR,
  MAILMIME_COMPOSITE_TYPE_MESSAGE,
  MAILMIME_COMPOSITE_TYPE_MULTIPART,
  MAILMIME_COMPOSITE_TYPE_EXTENSION
};

struct mailmime_composite_type {
  int ct_type;
  char * ct_token;
};

struct mailmime_composite_type *
mailmime_composite_type_new(int ct_type, char * ct_token);

void mailmime_composite_type_free(struct mailmime_composite_type * ct);
        </PRE
><P
>          This is a MIME composite type such as <B
CLASS="COMMAND"
>message</B
> or
          <B
CLASS="COMMAND"
>multipart</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>ct_type</B
> can have one of the 3 following values :
          <B
CLASS="COMMAND"
>MAILMIME_COMPOSITE_TYPE_MESSAGE</B
> when the
          composite MIME type 
          is <B
CLASS="COMMAND"
>message</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_COMPOSITE_TYPE_MULTIPART</B
> when
          the composite MIME type 
          is <B
CLASS="COMMAND"
> multipart</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_COMPOSITE_TYPE_EXTENSION</B
> for
          other and <B
CLASS="COMMAND"
>ct_token</B
> is set 
          in this case.
          <B
CLASS="COMMAND"
>MAILMIME_COMPOSITE_TYPE_ERROR</B
> is used
          internally on parse error. 
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_composite_type_new()</B
> creates and
          initializes 
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_composite_type_free()</B
> frees
          memory used by 
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1635"
></A
><P
><B
>Example 4-1. create and display MIME composite type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  struct mailmime_composite_type * ct;

  ct = mailmime_composite_type_new(MAILMIME_COMPOSITE_TYPE_MULTIPART, NULL);

  /* do your things ... */

  mailmime_composite_type_free(ct);

  exit(EXIT_SUCCESS);
}

void display_composite_type()
{
  switch (ct-&gt;type) {
  case MAILMIME_COMPOSITE_TYPE_MESSAGE:
    printf("composite type is message\n");
    break;
  case MAILMIME_COMPOSITE_TYPE_MULTIPART:
    printf("composite type is multipart\n");
    break;
  case MAILMIME_COMPOSITE_TYPE_EXTENSION:
    printf("composite type: %s\n", ct-&gt;ct_token);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-CONTENT"
>mailmime_content - MIME content type (Content-Type)</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_content {
  struct mailmime_type * ct_type;
  char * ct_subtype;
  clist * ct_parameters; /* elements are (struct mailmime_parameter *) */
};

struct mailmime_content *
mailmime_content_new(struct mailmime_type * ct_type,
		     char * ct_subtype,
		     clist * ct_parameters);

void mailmime_content_free(struct mailmime_content * content);
        </PRE
><P
>          This is a MIME content type such as <B
CLASS="COMMAND"
>message/rfc822</B
> or
          <B
CLASS="COMMAND"
>text/plain</B
>.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>ct_type</B
> is the main MIME type,
              for example <B
CLASS="COMMAND"
>text</B
> in
              <B
CLASS="COMMAND"
>plain/text</B
>
              (see <A
HREF="#MAILMIME-TYPE"
>the Section called <I
>mailmime_type - MIME main type</I
></A
>).
            </P
><P
>              <B
CLASS="COMMAND"
>ct_subtype</B
> is the MIME subtype,
              for example <B
CLASS="COMMAND"
>plain</B
> in
              <B
CLASS="COMMAND"
>plain/text</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>ct_parameters</B
> is the list of parameters for
              the given MIME type. For example, for <B
CLASS="COMMAND"
>plain/text</B
>,
              we can find <B
CLASS="COMMAND"
>charset=iso-8859-1</B
>,
              <B
CLASS="COMMAND"
>format=flowed</B
>. Each element of the list
              if of type <B
CLASS="COMMAND"
>struct mailmime_parameter *</B
>
              (see <A
HREF="#MAILMIME-PARAMETER"
>the Section called <I
>mailmime_parameter - MIME type parameter</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmime_content_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_content_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1667"
></A
><P
><B
>Example 4-2. Creation and display of MIME content type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  struct mailmime_content * content;
  struct mailmime_type * type;
  struct mailmime_discrete_type * dt;
  struct mailmime_parameter * param;
  clist * param_list;
  
  dt = mailmime_discrete_type_new(MAILMIME_DISCRETE_TYPE_TEXT, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_DISCRETE_TYPE, dt, NUL);
  param_list = clist_new();
  param = mailmime_parameter_new(strdup("charset"), strdup("iso-8859-1"));
  clist_append(param_list, param);
  
  content = mailmime_content_new(type, strdup("plain"), param_list);
  
  /* do your things */
  
  exit(EXIT_SUCCESS);
}

void display_mime_content(struct mailmime_content * content_type)
{
  clistiter * cur;

  printf("type:\n");
  display_type(content_type-&gt;ct_type);
  printf("\n");
  printf("subtype: %s\n", content_type-&gt;ct_subtype);
  printf("\n");
  
  for(cur = clist_begin(content_type-&gt;ct_parameters) ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailmime_parameter * param;
    
    param = clist_content(cur);
    display_mime_parameter(param);
    printf("\n");
  }
  printf("\n");
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISCRETE-TYPE"
>mailmime_discrete_type - MIME discrete type</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_DISCRETE_TYPE_ERROR,
  MAILMIME_DISCRETE_TYPE_TEXT,
  MAILMIME_DISCRETE_TYPE_IMAGE,
  MAILMIME_DISCRETE_TYPE_AUDIO,
  MAILMIME_DISCRETE_TYPE_VIDEO,
  MAILMIME_DISCRETE_TYPE_APPLICATION,
  MAILMIME_DISCRETE_TYPE_EXTENSION
};

struct mailmime_discrete_type {
  int dt_type;
  char * dt_extension;
};

struct mailmime_discrete_type *
mailmime_discrete_type_new(int dt_type, char * dt_extension);

void mailmime_discrete_type_free(struct mailmime_discrete_type *
				 discrete_type);
        </PRE
><P
>          This is a MIME discrete type such as <B
CLASS="COMMAND"
>text</B
> or
          <B
CLASS="COMMAND"
>image</B
>. This is also known as single part. This kind
          of part does not have any child.
        </P
><P
>          <B
CLASS="COMMAND"
>dt_type</B
> is one of the given values :
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_TEXT</B
> if part is text,
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_IMAGE</B
> if part is an image,
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_AUDIO</B
> if part is
          audio data, 
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_VIDEO</B
> if part is video,
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_APPLICATION</B
> if
          part is application data or 
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_EXTENSION</B
> for other.
          In the case of <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_EXTENSION</B
>,
          <B
CLASS="COMMAND"
>dt_extension</B
> is filled in.
          <B
CLASS="COMMAND"
>MAILMIME_DISCRETE_TYPE_ERROR</B
> is used internally.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_discrete_type_new()</B
> creates and
          initializes 
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_discrete_type_free()</B
> frees
          memory used by 
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1691"
></A
><P
><B
>Example 4-3. Creation and display of MIME discrete type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

/* standard type */

int main(int argc, char ** argv)
{
  struct mailmime_discrete_type * discrete_type;
  
  discrete_type = mailmime_discrete_type_new(MAILMIME_DISCRETE_TYPE_TEXT,
    NULL);
    
  /* do the things */
  
  mailmime_discrete_type_free(discrete_type);
}

/* extension */

int main(int argc, char ** argv)
{
  struct mailmime_discrete_type * discrete_type;
  
  discrete_type = mailmime_discrete_type_new(MAILMIME_DISCRETE_TYPE_EXTENSION,
    strdup("my-type"));
    
  /* do the things */
  
  mailmime_discrete_type_free(discrete_type);
}

void display_mime_discrete_type(struct mailmime_discrete_type * discrete_type)
{
  switch (discrete_type-&gt;dt_type) {
  case MAILMIME_DISCRETE_TYPE_TEXT:
    printf("text\n");
    break;
  case MAILMIME_DISCRETE_TYPE_IMAGE:
    printf("image\n");
    break;
  case MAILMIME_DISCRETE_TYPE_AUDIO:
    printf("audio\n");
    break;
  case MAILMIME_DISCRETE_TYPE_VIDEO:
    printf("video\n");
    break;
  case MAILMIME_DISCRETE_TYPE_APPLICATION:
    printf("application\n");
    break;
  case MAILMIME_DISCRETE_TYPE_EXTENSION:
    printf("extension : %s\n", discrete_type-&gt;dt_extension);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELD"
>mailmime_field - MIME header field</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_FIELD_NONE,
  MAILMIME_FIELD_TYPE,
  MAILMIME_FIELD_TRANSFER_ENCODING,
  MAILMIME_FIELD_ID,
  MAILMIME_FIELD_DESCRIPTION,
  MAILMIME_FIELD_VERSION,
  MAILMIME_FIELD_DISPOSITION,
  MAILMIME_FIELD_LANGUAGE,
};

struct mailmime_field {
  int fld_type;
  union {
    struct mailmime_content * fld_content;
    struct mailmime_mechanism * fld_encoding;
    char * fld_id;
    char * fld_description;
    uint32_t fld_version;
    struct mailmime_disposition * fld_disposition;
    struct mailmime_language * fld_language;
  } fld_data;
};

struct mailmime_field *
mailmime_field_new(int fld_type,
		   struct mailmime_content * fld_content,
		   struct mailmime_mechanism * fld_encoding,
		   char * fld_id,
		   char * fld_description,
		   uint32_t fld_version,
		   struct mailmime_disposition * fld_disposition,
		   struct mailmime_language * fld_language);

void mailmime_field_free(struct mailmime_field * field);
        </PRE
><P
>          This is a parsed MIME header field;
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_type</B
> is the type of MIME header field. The value can
              be 
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_TYPE</B
>
              if field is <B
CLASS="COMMAND"
>Content-Type</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_TRANSFER_ENCODING</B
>
              if field is <B
CLASS="COMMAND"
>Content-Transfer-Encoding</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_ID</B
>
              if field is <B
CLASS="COMMAND"
>Content-ID</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_DESCRIPTION</B
>
              if field is <B
CLASS="COMMAND"
>Content-Description</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_VERSION</B
>
              if field is <B
CLASS="COMMAND"
>MIME-Version</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_DISPOSITION</B
>
              if field is <B
CLASS="COMMAND"
>Content-Disposition</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_LANGUAGE</B
>
              if field is <B
CLASS="COMMAND"
>Content-Language</B
>.
              <B
CLASS="COMMAND"
>MAILMIME_FIELD_NONE</B
> is used internally.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_content</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-Type</B
>.
              (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_encoding</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-Transfer-Encoding</B
>.
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_id</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-ID</B
>. This is a string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_description</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-Description</B
>. This is a string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_version</B
> is set in case of 
              <B
CLASS="COMMAND"
>MIME-Version</B
>. This is an integer built
              using the following formula :
              <B
CLASS="COMMAND"
>fld_version = major * 2^16 + minor</B
>.
              Currenly MIME-Version is always <B
CLASS="COMMAND"
>1.0</B
>, this means that
              fld_version will always be <B
CLASS="COMMAND"
>2^16</B
> (in C language,
              this is <B
CLASS="COMMAND"
>1 &#60;&#60; 16</B
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_disposition</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-Disposition</B
>.
              (see <A
HREF="#MAILMIME-DISPOSITION"
>the Section called <I
>mailmime_disposition - MIME disposition information (Content-Disposition)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_data.fld_language</B
> is set in case of 
              <B
CLASS="COMMAND"
>Content-Language</B
>.
              (see <A
HREF="#MAILMIME-LANGUAGE"
>the Section called <I
>mailmime_language - Language of MIME part</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmime_field_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_field_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1757"
></A
><P
><B
>Example 4-4. Creation and display of MIME header field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_field * field;
  struct mailmime_mechanism * encoding;

  encoding = mailmime_mechanism_new(MAILMIME_MECHANISM_BASE64, NULL);

  field = mailmime_field_new(MAILMIME_FIELD_TRANSFER_ENCODING,
    NULL, encoding, NULL, NULL, 0, NULL, NULL);

  /* do the things */

  mailmime_field_free(field);
}

void display_mime_field(struct mailmime_field * field)
{
  switch (field-&gt;fld_type) {
  case MAILMIME_FIELD_TYPE:
    printf("content-type:");
    display_mime_content(field-&gt;fld_data.fld_content);
    break;
  case MAILMIME_FIELD_TRANSFER_ENCODING:
    printf("content-transfer-encoding:");
    display_mime_mechanism(field-&gt;fld_data.fld_encoding);
    break;
  case MAILMIME_FIELD_ID:
    printf("content-id: %s\n", field-&gt;fld_data.fld_id);
    break;
  case MAILMIME_FIELD_DESCRIPTION:
    printf("content-description: %s\n", field-&gt;fld_data.fld_description);
    break;
  case MAILMIME_FIELD_VERSION:
    printf("mime-version: %i.%i\n",
      field-&gt;version&#62;&#62; 16, field-&gt;fld_data.fld_version &#38; 0xFFFF);
    break;
  case MAILMIME_FIELD_DISPOSITION:
    printf("content-disposition:");
    display_mime_disposition(field-&gt;fld_data.fld_disposition);
    break;
  case MAILMIME_FIELD_LANGUAGE:
    printf("content-language:");
    display_mime_language(field-&gt;fld_data.fld_language);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-MECHANISM"
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_MECHANISM_ERROR,
  MAILMIME_MECHANISM_7BIT,
  MAILMIME_MECHANISM_8BIT,
  MAILMIME_MECHANISM_BINARY,
  MAILMIME_MECHANISM_QUOTED_PRINTABLE,
  MAILMIME_MECHANISM_BASE64,
  MAILMIME_MECHANISM_TOKEN
};

struct mailmime_mechanism {
  int enc_type;
  char * enc_token;
};

struct mailmime_mechanism * mailmime_mechanism_new(int enc_type, char * enc_token);

void mailmime_mechanism_free(struct mailmime_mechanism * mechanism);
        </PRE
><P
>          This is a MIME transfer encoding mechanism description.
        </P
><P
>          <B
CLASS="COMMAND"
>enc_type</B
> is an encoding type. The value of this field
          can be 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_7BIT</B
>
          if mechanism is <B
CLASS="COMMAND"
>7bit</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_8BIT</B
>
          if mechanism is <B
CLASS="COMMAND"
>8bit</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BINARY</B
>
          if mechanism is <B
CLASS="COMMAND"
>binary</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_QUOTED_PRINTABLE</B
>
          if mechanism is <B
CLASS="COMMAND"
>quoted-printable</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BASE64</B
>
          if mechanism is <B
CLASS="COMMAND"
>base64</B
> or
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_TOKEN</B
> for other.
          In case of <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_TOKEN</B
>, 
          field <B
CLASS="COMMAND"
>enc_token</B
> is filled in.
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_ERROR</B
> is used internally.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_mechanism_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_mechanism_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1784"
></A
><P
><B
>Example 4-5. Creation and display of MIME transfer encoding mechanism</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_mechanism * encoding;

  encoding = mailmime_mechanism_new(MAILMIME_MECHANISM_QUOTED_PRINTABLE, NULL);

  /* do the things */

  mailmime_mechanism_free(encoding);
}

int main(int argc, char ** argv)
{
  struct mailmime_mechanism * encoding;

  encoding = mailmime_mechanism_new(MAILMIME_MECHANISM_TOKEN,
    strdup("uuencoding"));

  /* do the things */

  mailmime_mechanism_free(encoding);
}

void display_mime_mechanism(struct mailmime_mechanism * encoding)
{
  switch (encoding-&gt;enc_type) {
  case MAILMIME_MECHANISM_7BIT:
    printf("7bit\n");
    break;
  case MAILMIME_MECHANISM_8BIT:
    printf("8bit\n");
    break;
  case MAILMIME_MECHANISM_BINARY:
    printf("binary\n");
    break;
  case MAILMIME_MECHANISM_QUOTED_PRINTABLE:
    printf("quoted-printable\n");
    break;
  case MAILMIME_MECHANISM_BASE64:
    printf("base64\n");
    break;
  case MAILMIME_MECHANISM_TOKEN:
    printf("extension : %s\n", encoding-&gt;enc_token);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS"
>mailmime_fields - header fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_fields {
  clist * fld_list; /* list of (struct mailmime_field *) */
};

struct mailmime_fields * mailmime_fields_new(clist * fld_list);

void mailmime_fields_free(struct mailmime_fields * fields);
        </PRE
><P
>          This is the header fields of a MIME part.
        </P
><P
>          <B
CLASS="COMMAND"
>fld_list</B
> is the list of the header fields.
          Each element of the list is a <B
CLASS="COMMAND"
>mailmime_field</B
>
          (See <A
HREF="#MAILMIME-FIELD"
>the Section called <I
>mailmime_field - MIME header field</I
></A
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1799"
></A
><P
><B
>Example 4-6. Creation and display of MIME fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_field * field;
  struct mailmime_fields * fields;
  clist * list;
  struct mailmime_mechanism * encoding;
  struct mailmime_disposition * disposition;

  list = clist_new();

  encoding = mailmime_mechanism_new(MAILMIME_MECHANISM_BASE64, NULL);
  field = mailmime_field_new(MAILMIME_FIELD_TRANSFER_ENCODING,
    NULL, encoding, NULL, NULL, 0, NULL, NULL);
  clist_append(list, field);

  field = mailmime_field_new(MAILMIME_FIELD_VERSION,
    NULL, NULL, NULL, NULL, 1 &#60;&#60; 16, NULL, NULL);
  clist_append(list, field);

  /* look at the example in mailmime_disposition to see how to
     build a mailmime_disposition */
  disposition = build_mime_disposition();
  field = mailmime_field_new(MAILMIME_FIELD_DISPOSITION,
    NULL, NULL, NULL, NULL, 0, disposition, NULL);
  clist_append(list, field);

  fields = mailmime_fields_new(list);

  /* do the things */

  mailmime_fields_free(fields);
}

void display_mime_fields(struct mailmime_fields * fields)
{
  clistiter * cur;

  for(cur = clist_begin(fields-&gt;fld_list ; cur != NULL ;
    cur = clist_next(cur)) {
    struct mailmime_field * field;

    field = clist_content(cur);
    display_field(field);
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-PARAMETER"
>mailmime_parameter - MIME type parameter</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>struct mailmime_parameter {
  char * pa_name;
  char * pa_value;
};
        </PRE
><P
>          This is the MIME type parameter in
          <B
CLASS="COMMAND"
>Content-Type</B
> MIME header 
          field. For example, this can be
          <B
CLASS="COMMAND"
>charset="iso-8859-1"</B
>. 
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>pa_name</B
> is the name of the parameter,
              for example : <B
CLASS="COMMAND"
>charset</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_value</B
> is the value of the parameter,
              for example : <B
CLASS="COMMAND"
>iso-8859-1</B
>.
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmime_parameter_new()</B
> creates and initializes
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_parameter_free()</B
> frees memory used by
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1821"
></A
><P
><B
>Example 4-7. Creation and display of MIME type parameter</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_parameter * param;

  param = mailmime_parameter_new(strdup("charset"), strdup("iso-8859-1"));

  /* do the things */

  mailmime_parameter_free(param);
}

void display_mime_parameter(struct mailmime_parameter * param)
{
  printf("%s = %s\n", param-&gt;pa_name, param-&gt;pa_value);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-TYPE"
>mailmime_type - MIME main type</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_TYPE_ERROR,
  MAILMIME_TYPE_DISCRETE_TYPE,
  MAILMIME_TYPE_COMPOSITE_TYPE
};

struct mailmime_type {
  int tp_type;
  union {
    struct mailmime_discrete_type * tp_discrete_type;
    struct mailmime_composite_type * tp_composite_type;
  } tp_data;
};

struct mailmime_type *
mailmime_type_new(int tp_type,
		  struct mailmime_discrete_type * tp_discrete_type,
		  struct mailmime_composite_type * tp_composite_type);

void mailmime_type_free(struct mailmime_type * type);
        </PRE
><P
>         This is the MIME main type (no subtype, no parameter).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>tp_type</B
>. The value of this field
              is either <B
CLASS="COMMAND"
>MAILMIME_TYPE_DISCRETE_TYPE</B
> for MIME discrete type,
              or <B
CLASS="COMMAND"
>MAILMIME_TYPE_COMPOSITE_TYPE</B
> for MIME composite type.
              <B
CLASS="COMMAND"
>MAILMIME_TYPE_ERROR</B
> is used internally.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>tp_data.tp_discrete_type</B
> is set when <B
CLASS="COMMAND"
>tp_type</B
>
              is <B
CLASS="COMMAND"
>MAILMIME_TYPE_DISCRETE_TYPE</B
>
              (see <A
HREF="#MAILMIME-DISCRETE-TYPE"
>the Section called <I
>mailmime_discrete_type - MIME discrete type</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>tp_data.tp_composite_type</B
> is set when <B
CLASS="COMMAND"
>tp_type</B
>
              is <B
CLASS="COMMAND"
>MAILMIME_TYPE_COMPOSITE_TYPE</B
>
              (see <A
HREF="#MAILMIME-COMPOSITE-TYPE"
>the Section called <I
>mailmime_composite_type - Composite MIME type</I
></A
>).
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmime_discrete_type_new()</B
> creates and
          initializes 
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_discrete_type_free()</B
> frees
          memory used by 
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1851"
></A
><P
><B
>Example 4-8. Creation and display of MIME main type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_type * type;
  struct mailmime_discrete_type * discrete_type;

  discrete_type =
    mailmime_discrete_type_new(MAILMIME_DISCRETE_TYPE_TEXT, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_DISCRETE_TYPE, discrete_type, NULL);

  /* do the things */

  mailmime_type_free(type);
}

int main(int argc, char ** argv)
{
  struct mailmime_type * type;
  struct mailmime_composite_type * composite_type;

  composite_type =
    mailmime_composite_type_new(MAILMIME_COMPOSITE_TYPE_MULTIPART, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_COMPOSITE_TYPE, NULL, composite_type);

  /* do the things */

  mailmime_type_free(type);
}

void display_mime_type(struct mailmime_type * type)
{
  printf("mime type:\n");
  switch (type-&gt;tp_type) {
  case MAILMIME_TYPE_DISCRETE_TYPE:
    printf("discrete type:\n");
    display_mime_discrete_type(type-&gt;tp_data.tp_discrete_type);
    break;
  case MAILMIME_TYPE_COMPOSITE_TYPE:
    printf("composite type:\n");
    display_mime_composite_type(type-&gt;tp_data.tp_composite_type);
    break;
  }
  printf("\n");
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-LANGUAGE"
>mailmime_language - Language of MIME part</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_language {
  clist * lg_list; /* atom (char *) */
};

struct mailmime_language * mailmime_language_new(clist * lg_list);

void mailmime_language_free(struct mailmime_language * lang);
        </PRE
><P
>          This is the language used in the MIME part.
        </P
><P
>          <B
CLASS="COMMAND"
>lg_list</B
> is the list of codes of languages used
          in the MIME part. This is a list of strings.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_language_new()</B
> creates and
          initializes 
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_language_free()</B
> frees
          memory used by 
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1864"
></A
><P
><B
>Example 4-9. Creation and display of language of MIME part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_language * language;
  clist * list;

  list = clist_new();

  clist_append(list, strdup("fr"));
  clist_append(list, strdup("en"));

  language = mailmime_language_new(list);

  /* do the things */

  mailmime_language_free(language);
}

void display_mime_language(struct mailmime_language * language)
{
  clistiter * cur;

  printf("languages: ");
  for(cur = clist_begin(language-&gt;lg_list) ; cur != NULL ;
    cur = clist_next(cur)) {
    char * name;

    name = clist_content(cur);
    printf("%s ", name);
  }
  printf("\n");
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DATA"
>mailmime_data - Content of MIME part</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_DATA_TEXT,
  MAILMIME_DATA_FILE,
};

enum {
  MAILMIME_MECHANISM_ERROR,
  MAILMIME_MECHANISM_7BIT,
  MAILMIME_MECHANISM_8BIT,
  MAILMIME_MECHANISM_BINARY,
  MAILMIME_MECHANISM_QUOTED_PRINTABLE,
  MAILMIME_MECHANISM_BASE64,
  MAILMIME_MECHANISM_TOKEN
};

struct mailmime_data {
  int dt_type;
  int dt_encoding;
  int dt_encoded;
  union {
    struct {
      const char * dt_data;
      size_t dt_length;
    } dt_text;
    char * dt_filename;
  } dt_data;
};

struct mailmime_data * mailmime_data_new(int dt_type, int dt_encoding,
    int dt_encoded, const char * dt_data, size_t dt_length,
    char * dt_filename);

void mailmime_data_free(struct mailmime_data * mime_ </PRE
><P
>          This is the content of MIME part, content of 
          preamble or content of epilogue.
        </P
><P
>          <B
CLASS="COMMAND"
>dt_type</B
> can be
          <B
CLASS="COMMAND"
>MAILMIME_DATA_TEXT</B
> if 
          the content is a string in memory,
          <B
CLASS="COMMAND"
>MAILMIME_DATA_FILE</B
> if the 
          content is in a file,
        </P
><P
>          <B
CLASS="COMMAND"
>dt_encoding</B
> is the encoding mechanism 
          of the part. The value of this field can be 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_7BIT</B
> if mechanism is 
          <B
CLASS="COMMAND"
>7bit</B
>, 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_8BIT</B
> if mechanism is 
          <B
CLASS="COMMAND"
>8bit</B
>, 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BINARY</B
> if mechanism is 
          <B
CLASS="COMMAND"
>binary</B
>, 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_QUOTED_PRINTABLE</B
> if 
          mechanism is <B
CLASS="COMMAND"
>quoted-printable</B
>,
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BASE64</B
> if mechanism is 
          <B
CLASS="COMMAND"
>base64</B
> or 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_TOKEN</B
> for other. If 
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_TOKEN</B
>, the part will
          be considered as binary.
          <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_ERROR</B
> is used internally.
        </P
><P
>          <B
CLASS="COMMAND"
>dt_encoded</B
> is set to 1 if the part is 
          already encoded with the mechanism given in
          <B
CLASS="COMMAND"
>dt_encoding</B
>. It is set to 0 if the part
          is already decoded or if it is necessary to encode that part 
          before rendering it.
        </P
><P
>          <B
CLASS="COMMAND"
>dt_data.dt_text.dt_data</B
> is a pointer to the
          content of the part and <B
CLASS="COMMAND"
>dt_data.dt_text.dt_length</B
>
          is the length of the data if <B
CLASS="COMMAND"
>dt_type</B
> is
          <B
CLASS="COMMAND"
>MAILMIME_DATA_TEXT</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>dt_data.dt_filename</B
> is the name of the file if
          <B
CLASS="COMMAND"
>dt_type</B
> is <B
CLASS="COMMAND"
>MAILMIME_DATA_FILE</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_data_new()</B
> creates and
          initializes 
          a data structure with a value.
          Structures given as argument are referenced by the created
          object and will be freed if the object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_data_free()</B
> frees
          memory used by 
          the structure and substructures will also be released.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN1906"
></A
><P
><B
>Example 4-10. Creation and display of MIME part content</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

/* build data with a string */

int main(int argc, char ** argv)
{
  struct mailmime_data * data;

  data = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_BASE64,
    0, "foo bar", 7, NULL);
  
  /* do the things */
  
  mailmime_data_free(data);
}

/* build data with a file */

int main(int argc, char ** argv)
{
  struct mailmime_data * data;

  data = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_BASE64,
    0, NULL, 0, strdup("foo.txt"));
  
  /* do the things */
  
  mailmime_data_free(data);
}

void display_mime_data(struct mailmime_data * data)
{
  switch (data-&gt;dt_encoding) {
  case MAILMIME_MECHANISM_7BIT:
    printf("7bit\n");
    break;
  case MAILMIME_MECHANISM_8BIT:
    printf("8bit\n");
    break;
  case MAILMIME_MECHANISM_BINARY:
    printf("binary\n");
    break;
  case MAILMIME_MECHANISM_QUOTED_PRINTABLE:
    printf("quoted-printable\n");
    break;
  case MAILMIME_MECHANISM_BASE64:
    printf("base64\n");
    break;
  case MAILMIME_MECHANISM_TOKEN:
    printf("other\n");
    break;
  }

  if (data-&gt;dt_encoded)
    printf("already encoded\n");
  else
    printf("not encoded\n");
  
  switch (data-&gt;dt_type) {
  MAILMIME_DATA_TEXT:
    printf("data : %p %i\n", data-&#62;dt_data.dt_text.dt_data,
      data-&#62;dt_data.dt_text.dt_length);
    break;
  MAILMIME_DATA_FILE,
    printf("data (file) : %s\n", data-&#62;dt_data.dt_filename);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME"
>mailmime - MIME part</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_NONE,
  MAILMIME_SINGLE,
  MAILMIME_MULTIPLE,
  MAILMIME_MESSAGE,
};

struct mailmime {
  /* parent information */
  int mm_parent_type;
  struct mailmime * mm_parent;
  clistiter * mm_multipart_pos;

  int mm_type;
  const char * mm_mime_start;
  size_t mm_length;
  
  struct mailmime_fields * mm_mime_fields;
  struct mailmime_content * mm_content_type;
  
  struct mailmime_data * mm_body;
  union {
    /* single part */
    struct mailmime_data * mm_single; /* XXX - was body */
    
    /* multi-part */
    struct {
      struct mailmime_data * mm_preamble;
      struct mailmime_data * mm_epilogue;
      clist * mm_mp_list;
    } mm_multipart;
    
    /* message */
    struct {
      struct mailimf_fields * mm_fields;
      struct mailmime * mm_msg_mime;
    } mm_message;
    
  } mm_data;
};

struct mailmime * mailmime_new(int mm_type,
    const char * mm_mime_start, size_t mm_length,
    struct mailmime_fields * mm_mime_fields,
    struct mailmime_content * mm_content_type,
    struct mailmime_data * mm_body,
    struct mailmime_data * mm_preamble,
    struct mailmime_data * mm_epilogue,
    clist * mm_mp_list,
    struct mailimf_fields * mm_fields,
    struct mailmime * mm_msg_mime);

void mailmime_free(struct mailmime * mime);
        </PRE
><P
>          This describes the MIME structure of a message or a subpart
          of a message.
        </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1913"
>common</A
></H4
><P
></P
><UL
><LI
><P
>                <B
CLASS="COMMAND"
>mm_parent_type</B
>. MIME part type can be
                single part, multipart or message part. This describes the MIME part
                type of the parent. The value can be 
                <B
CLASS="COMMAND"
>MAILMIME_NONE</B
> if there is no parent part,
                <B
CLASS="COMMAND"
>MAILMIME_SINGLE</B
> if parent is a single part,
                <B
CLASS="COMMAND"
>MAILMIME_MULTIPLE</B
> if parent is a multipart,
                <B
CLASS="COMMAND"
>MAILMIME_MESSAGE</B
> if parent is a mesage part.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_parent</B
> is the parent MIME structure.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_multipart_pos</B
>. In the case the parent
                is a multipart. This is the position in the list of children
                of the parent. This position is given by a
                <B
CLASS="COMMAND"
>clisiter *</B
>.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_type</B
>. This describes the MIME part type
                of this part. The value can be
                <B
CLASS="COMMAND"
>MAILMIME_SINGLE</B
> if this is a single part,
                <B
CLASS="COMMAND"
>MAILMIME_MULTIPLE</B
> if this is a multipart,
                <B
CLASS="COMMAND"
>MAILMIME_MESSAGE</B
> if this is a mesage part.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_mime_start</B
>. This is used mostly internally.
                This gives the beginning of the header of the MIME part, when this
                is parsed from a string in memory.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_length</B
>. This gives the length of the MIME part,
                including the MIME header fields.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_mime_fields</B
> is the list of parsed MIME headers
                of this part. <B
CLASS="COMMAND"
>Content-Type</B
> must be excluded and stored
                in <B
CLASS="COMMAND"
>mm_content_type</B
> instead
                (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_content_type</B
> is the parsed
                <B
CLASS="COMMAND"
>Content-Type</B
> field
                (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_body</B
> is the content of the MIME part
                (excluding MIME header), when it is parsed from a string
                in memory
                (see <A
HREF="#MAILMIME-DATA"
>the Section called <I
>mailmime_data - Content of MIME part</I
></A
>).
              </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1957"
>single part</A
></H4
><P
></P
><UL
><LI
><P
>                When the part is a single part (<B
CLASS="COMMAND"
>mm_type</B
>
                is <B
CLASS="COMMAND"
>MAILMIME_SINGLE</B
>). The following fields
                are valid.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_single</B
> is the content of the
                MIME part (excluding MIME header), when it is parsed from a string
                in memory. This must have the same
                value as <B
CLASS="COMMAND"
>mm_body</B
> when it is set
                (see <A
HREF="#MAILMIME-DATA"
>the Section called <I
>mailmime_data - Content of MIME part</I
></A
>).
              </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1969"
>multipart</A
></H4
><P
></P
><UL
><LI
><P
>                When the part is a multipart (<B
CLASS="COMMAND"
>mm_type</B
>
                is <B
CLASS="COMMAND"
>MAILMIME_MULTIPLE</B
>). The following fields
                are valid.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_multipart.mm_preamble</B
>
                is the content of the preamble of the multipart
                (see <A
HREF="#MAILMIME-DATA"
>the Section called <I
>mailmime_data - Content of MIME part</I
></A
>).
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_multipart.mm_epilogue</B
>
                is the content of the epilogue of the multipart
                (see <A
HREF="#MAILMIME-DATA"
>the Section called <I
>mailmime_data - Content of MIME part</I
></A
>).
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_multipart.mm_mp_list</B
>
                is the list of sub parts 
              </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1987"
>message part</A
></H4
><P
></P
><UL
><LI
><P
>                When the part is a message (<B
CLASS="COMMAND"
>mm_type</B
>
                is <B
CLASS="COMMAND"
>MAILMIME_MESSAGE</B
>). The following fields
                are valid.
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_message.mm_fields</B
> is the list of
                the header fields of the message
                (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
> in Chapter 3</A
>).
              </P
></LI
><LI
><P
>                <B
CLASS="COMMAND"
>mm_data.mm_message.mm_msg_mime</B
> is
                the subpart 
                of the message part.
              </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2001"
>constructor and destructor</A
></H4
><P
>            <B
CLASS="COMMAND"
>mailmime_new()</B
> creates and
            initializes 
            a data structure with a value.
            Structures given as argument are referenced by the created
            object and will be freed if the object is released.
          </P
><P
>            <B
CLASS="COMMAND"
>mailmime_free()</B
> frees
            memory used by 
            the structure and substructures will also be released.
          </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2007"
></A
><P
><B
>Example 4-11. Creation and display of MIME part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

/* build one single MIME part */

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailimf_fields * fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;
  struct mailmime_data * body;
  
  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_fields();
  
  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();

  /* look at the example in mailmime_content to see how to
     build a mailmime_content */
  content_type = build_mime_content();
  
  body = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_8BIT, 0,
    "foo", 3, NULL);
  
  mime = mailmime_new(MAILMIME_SINGLE,
    NULL, 0, fields, mime_fields, content_type,
    body, NULL, NULL, NULL, NULL, NULL);
  
  /* do the things */

  mailmime_free(mime);
}

/* build one single MIME part */

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailimf_fields * fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;
  char * str;
  struct mailmime_data * body;
  
  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_fields();
  
  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();

  /* look at the example in mailmime_content to see how to
     build a mailmime_content */
  content_type = build_mime_content();
  
  str = malloc(4);
  strcpy(str, "foo");
  
  body = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_8BIT, 0,
    str, 3, NULL);
  
  mime = mailmime_new(MAILMIME_SINGLE,
    NULL, 0, fields, mime_fields, content_type,
    body, NULL, NULL, NULL, NULL, NULL);
  
  /* do the things */
  
  mailmime_free(mime);
  free(str);
}

/* build a MIME part with a sub-message */

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailimf_fields * fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;
  char * str;
  struct mailmime_type * type;
  struct mailmime_composite_type * composite_type;
  
  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_fields();
  
  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();
  
  composite_type =
    mailmime_composite_type_new(MAILMIME_COMPOSITE_TYPE_MESSAGE, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_COMPOSITE_TYPE, NULL,
    composite_type);
  content_type = mailmime_content_new(type, strdup("rfc2822"), NULL);
  
  /* build_mime_message() is a function that will build a mime message part */
  sub_mime = build_mime_message();
  
  mime = mailmime_new(MAILMIME_MESSAGE,
    NULL, 0, fields, mime_fields, content_type,
    NULL, NULL, NULL, NULL, sub_mime, NULL);
  
  /* do the things */
  
  mailmime_free(mime);
}

/* build a MIME part with a sub-message (given by a string) */


int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailimf_fields * fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;
  char * str;
  struct mailmime_data * msg_content;
  struct mailmime_type * type;
  struct mailmime_composite_type * composite_type;
  
  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_fields();
  
  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();
  
  composite_type =
    mailmime_composite_type_new(MAILMIME_COMPOSITE_TYPE_MESSAGE, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_COMPOSITE_TYPE, NULL,
    composite_type);
  content_type = mailmime_content_new(type, strdup("rfc2822"), NULL);
  
  str = malloc(sizeof(SUB_MESSAGE));
  strcpy(str, SUB_MESSAGE);
  
  msg_content = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_8BIT, 0,
    str, sizeof(SUB_MESSAGE), NULL);

  mime = mailmime_new(MAILMIME_MESSAGE,
    NULL, 0, fields, mime_fields, content_type,
    NULL, NULL, NULL, NULL, NULL, msg_content);
  
  /* do the things */
  
  mailmime_free(mime);
  free(str);
}

/* build a multipart message */



int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailimf_fields * fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;
  struct mailmime_type * type;
  struct mailmime_composite_type * composite_type;
  struct mailmime_data * body;
  struct mailmime_data * preamble;
  struct mailmime_data * epilogue;
  clist * list;
  
  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  fields = build_fields();
  
  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();

  composite_type =
    mailmime_composite_type_new(MAILMIME_COMPOSITE_TYPE_MULTIPART, NULL);
  type = mailmime_type_new(MAILMIME_TYPE_COMPOSITE_TYPE, NULL,
    composite_type);
  content_type = mailmime_content_new(type, strdup("mixed"), NULL);
  
  list = clist_new();
  /* build_mime_message() is a function that will build a mime message part */
  sub_mime = build_mime_message();
  clist_append(list, sub_mime);
  sub_mime = build_mime_message();
  clist_append(list, sub_mime);
  
  preamble = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_8BIT, 0,
    PREAMBLE, sizeof(PREAMBLE), NULL);

  epilogue = mailmime_data_new(MAILMIME_DATA_TEXT, MAILMIME_MECHANISM_8BIT, 0,
    EPILOGUE, sizeof(EPILOGUE), NULL);
  
  mime = mailmime_new(MAILMIME_SINGLE,
    NULL, 0, fields, mime_fields, content_type,
    NULL, preamble, epilogue, list, NULL, NULL);
  
  /* do the things */

  mailmime_free(mime);
}

/* display mime part info */

void display_mime(struct mailmime * mime)
{
  clistiter * cur;
  
  switch (mime-&gt;mm_type) {
  case MAILMIME_SINGLE:
    printf("single part\n");
    break;
  case MAILMIME_MULTIPLE:
    printf("multipart\n");
    break;
  case MAILMIME_MESSAGE:
    printf("message\n");
    break;
  }

  printf("part : %p, length : %i\n",
    mime-&gt;mm_mime_start, mime-&gt;mm_length);
  printf("\n");
  
  if (mime-&gt;mm_mime_fields != NULL) {
    printf("MIME headers :\n");
    display_mime_fields(mime-&#62;mm_mime_fields);
    printf("\n");
  }

  printf("content type :\n");
  display_content(mime-&gt;mm_content_type);
  printf("\n");

  switch (mime-&gt;mm_type) {
  case MAILMIME_SINGLE:
    display_mime_data(mime-&gt;mm_data.mm_single);
    break;
    
  case MAILMIME_MULTIPLE:
    if (mime-&gt;mm_data.mm_multipart.mm_preamble) {
      printf("preamble :\n");
      display_mime_data(mime-&gt;mm_data.mm_multipart.mm_preamble);
      printf("\n");
    }
    
    for(cur = clist_begin(mime-&#62;mm_data.mm_multipart.mm_mp_list) ;
      cur != NULL ; cur = clist_next(cur)) {
      display_mime(clist_content(cur));
    }
    
    if (mime-&gt;mm_data.mm_multipart.mm_epilogue) {
      printf("epilogue :\n");
      display_mime_data(mime-&gt;mm_data.mm_multipart.mm_epilogue);
      printf("\n");
    }
    break;
    
  case MAILMIME_MESSAGE:
    if (mime-&gt;mm_data.mm_message.mm_fields) {
      printf("headers :\n");
      display_field(mime-&gt;mm_data.mm_message.mm_msg_fields);
      printf("\n");
    
    if (mime-&gt;mm_data.mm_message.mm_msg_mime != NULL) {
      printf("sub message %p :\n",
        mime-&gt;mm_data.mm_message.mm_msg_mime);
      display_mime(mime-&gt;mm_data.mm_message.mm_msg_mime);
      printf("end of sub message %p\n",
        mime-&gt;mm_data.mm_message.mm_msg_mime);
    }
    break;
  }
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION"
>mailmime_disposition - MIME disposition information (Content-Disposition)</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_disposition {
  struct mailmime_disposition_type * dsp_type;
  clist * dsp_parms; /* struct mailmime_disposition_parm */
};
        </PRE
><P
>          This is the parsed <B
CLASS="COMMAND"
>Content-Disposition</B
>
          header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>dsp_type</B
> is the type of disposition
              (see <A
HREF="#MAILMIME-DISPOSITION-TYPE"
>the Section called <I
>mailmime_disposition_type - Type of MIME disposition</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dsp_parms</B
> is the list of parameters
              of <B
CLASS="COMMAND"
>Content-Disposition</B
> header field.
              Each element is of type <B
CLASS="COMMAND"
>mailmime_disposition_parm</B
>
              (see <A
HREF="#MAILMIME-DISPOSITION-PARM"
>the Section called <I
>mailmime_disposition_parm - MIME disposition parameter</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2026"
></A
><P
><B
>Example 4-12. Creation and display of MIME disposition information</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_disposition * disposition;
  struct mailmime_disposition_type * disposition_type;
  clist * disposition_parms;
  struct mailmime_disposition_parm * param;

  disposition_type =
    mailmime_disposition_type_new(MAILMIME_DISPOSITION_TYPE_ATTACHMENT, NULL);

  disposition_parms = clist_new();
  param = mailmime_disposition_parm_new(MAILMIME_DISPOSITION_PARM_FILENAME,
			      strdup("foo.txt"), NULL,
			      NULL, NULL, -1, NULL);
  clist_append(disposition_parms, param);
  
  disposition = mailmime_disposition_new(disposition_type, disposition_parms);

  /* do the things */
  
  mailmime_disposition_free(disposition);
}

void display_mime_disposition(struct mailmime_disposition * disposition)
{
  clistiter * cur;

  printf("disposition type:\n");
  display_mailmime_disposition_type(disposition-&gt;dsp_type);
  printf("\n");
  printf("disposition parameters:\n");
  for(cur = clist_begin(disposition-&gt;dsp_parms) ;
    cur != NULL ; cur = clist_next(cur)) {
    struct mailmime_parm * param;

    param = clist_content(cur);
    display_mime_disposition_parm(param);
  }
  printf("\n");
}

          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION-TYPE"
>mailmime_disposition_type - Type of MIME disposition</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_DISPOSITION_TYPE_ERROR,
  MAILMIME_DISPOSITION_TYPE_INLINE,
  MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
  MAILMIME_DISPOSITION_TYPE_EXTENSION
};

struct mailmime_disposition_type {
  int dsp_type;
  char * dsp_extension;
};
        </PRE
><P
>          This is the type of MIME disposition.
          Parsed <B
CLASS="COMMAND"
>Content-Disposition</B
> field without
          parameters.
        </P
><P
>          <B
CLASS="COMMAND"
>dsp_type</B
> is the type of disposition.
          The value can be 
          <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_INLINE</B
>
          if MIME disposition is inline,
          <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_ATTACHMENT</B
>
          if MIME disposition is attachment,
          <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_EXTENSION</B
>
          for other. In this case, <B
CLASS="COMMAND"
>dsp_extension</B
> must be
          set.
          <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_ERROR</B
> is used internally.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2041"
></A
><P
><B
>Example 4-13. Creation and display of MIME disposition type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

/* standard disposition type */

int main(int argc, char ** argv)
{
  struct mailmime_disposition_type * disposition_type;

  disposition_type =
    mailmime_disposition_type_new(MAILMIME_DISPOSITION_TYPE_ATTACHMENT, NULL);

  /* do the things */

  mailmime_disposition_type_free(disposition_type);
}

/* disposition type extension */

int main(int argc, char ** argv)
{
  struct mailmime_disposition_type * disposition_type;

  disposition_type =
    mailmime_disposition_type_new(MAILMIME_DISPOSITION_TYPE_EXTENSION,
      strdup("mydisposition"));

  /* do the things */

  mailmime_disposition_type_free(disposition_type);
}

void display_mime_disposition_type(struct mailmime_disposition_type * disposition_type)
{
  switch (disposition-&gt;dsp_type) {
  case MAILMIME_DISPOSITION_TYPE_INLINE:
    printf("inline\n");
    break;
  case MAILMIME_DISPOSITION_TYPE_ATTACHMENT:
    printf("attachment\n");
    break;
  case MAILMIME_DISPOSITION_TYPE_EXTENSION:
    printf("extension : %s\n", disposition_type-&gt;dsp_extension);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION-PARM"
>mailmime_disposition_parm - MIME disposition parameter</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_DISPOSITION_PARM_FILENAME,
  MAILMIME_DISPOSITION_PARM_CREATION_DATE,
  MAILMIME_DISPOSITION_PARM_MODIFICATION_DATE,
  MAILMIME_DISPOSITION_PARM_READ_DATE,
  MAILMIME_DISPOSITION_PARM_SIZE,
  MAILMIME_DISPOSITION_PARM_PARAMETER
};

struct mailmime_disposition_parm {
  int pa_type;
  union {
    char * pa_filename;
    char * pa_creation_date;
    char * pa_modification_date;
    char * pa_read_date;
    size_t pa_size;
    struct mailmime_parameter * pa_parameter;
  } pa_data;
};
        </PRE
><P
>          This is a parameter of MIME disposition information. For
          example, this can be
          <B
CLASS="COMMAND"
>filename="foo.jpg"</B
>.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>pa_type</B
> is the type of
              disposition. The value can be
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_FILENAME</B
>
              for a filename parameter,
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_CREATION_DATE</B
>
              for a creation date parameter,
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_MODIFICATION_DATE</B
>
              for a modification date parameter,
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_READ_DATE</B
>
              for a last read date parameter,
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_SIZE</B
>
              for a file size parameter or
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_PARAMETER</B
>
              for other parameters.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_filename</B
> is the filename
              parameter when <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_FILENAME</B
>
              This is a string containing the name of the
              file.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_creation_date</B
> is the 
              creation date parameter when <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_CREATION_DATE</B
>.
              This is a string containing the formatted creation date.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_modification_date</B
> is the
              modification date parameter when <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_MODIFICATION_DATE</B
>.
              This is a string containing the formatted modification date.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_read_date</B
> is the
              last read date parameter when <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_READ_DATE</B
>.
              This is a string containing the formatted last read date.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_size</B
> is the size
              parameter when <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_SIZE</B
>.
              This gives the size of the file.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>pa_data.pa_parameter</B
> is the
              name and the value of the parameter when
              <B
CLASS="COMMAND"
>pa_type</B
> is
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_PARM_PARAMETER</B
>
              (see <A
HREF="#MAILMIME-PARAMETER"
>the Section called <I
>mailmime_parameter - MIME type parameter</I
></A
>)
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2090"
></A
><P
><B
>Example 4-14. Creation and display of MIME disposition
          parameter</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(int argc, char ** argv)
{
  struct mailmime_disposition_parm * param;

  disposition_parms = clist_new();
  param = mailmime_disposition_parm_new(MAILMIME_DISPOSITION_PARM_FILENAME,
			      strdup("foo.txt"), NULL,
			      NULL, NULL, -1, NULL);
  /* do the things */

  mailmime_disposition_parm_free(param);
}

void display_mime_dsp_parm(struct mailmime_disposition_parm * param)
{
  switch (param-&gt;pa_type) {
  case MAILMIME_DISPOSITION_PARM_FILENAME:
    printf("filename: %s\n", param-&gt;pa_data.pa_filename);
    break;
  case MAILMIME_DISPOSITION_PARM_CREATION_DATE:
    printf("creation date: %s\n", param-&gt;pa_data.pa_creation_date);
    break;
  case MAILMIME_DISPOSITION_PARM_MODIFICATION_DATE:
    printf("modification date: %s\n", param-&gt;pa_data.pa_modification_date);
    break;
  case MAILMIME_DISPOSITION_PARM_READ_DATE:
    printf("read date: %s\n", param-&gt;pa_data.pa_read_date);
    break;
  case MAILMIME_DISPOSITION_PARM_SIZE:
    printf("size: %lu\n", (unsigned long) param-&gt;pa_data.pa_size);
    break;
  case MAILMIME_DISPOSITION_PARM_PARAMETER:
    printf("MIME disposition param:\n");
    display_mime_parameter(param-&gt;pa_data.pa_parameter);
    break;
  }
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-SINGLE-FIELDS"
>mailmime_single_fields - MIME headers</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_single_fields {
  struct mailmime_content * fld_content;
  char * fld_content_charset;
  char * fld_content_boundary;
  char * fld_content_name;
  struct mailmime_mechanism * fld_encoding;
  char * fld_id;
  char * fld_description;
  uint32_t fld_version;
  struct mailmime_disposition * fld_disposition;
  char * fld_disposition_filename;
  char * fld_disposition_creation_date;
  char * fld_disposition_modification_date;
  char * fld_disposition_read_date;
  size_t fld_disposition_size;
  struct mailmime_language * fld_language;
};

struct mailmime_single_fields *
mailmime_single_fields_new(struct mailmime_fields * fld_fields,
    struct mailmime_content * fld_content);

void mailmime_single_fields_free(struct mailmime_single_fields *
    single_fields);

void mailmime_single_fields_init(struct mailmime_single_fields * single_fields,
    struct mailmime_fields * fld_fields,
    struct mailmime_content * fld_content);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_fields</B
> (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>) is the native structure
          that MIME module will use, this module will provide an easier
          structure to use when
          parsing fields. <B
CLASS="COMMAND"
>mailmime_single_fields</B
> is
          an easier structure to get parsed fields, rather than
          iteration over the list of fields.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_content</B
> is the MIME content type
              (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_content_charset</B
> is the value
              of the MIME type parameter <B
CLASS="COMMAND"
>charset</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_content_boundary</B
> is the value
              of the MIME type parameter <B
CLASS="COMMAND"
>boundary</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_content_name</B
> is the value
              of the MIME type parameter <B
CLASS="COMMAND"
>name</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_encoding</B
> is the MIME encoding
              mechanism used
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_id</B
> is the content of the field
              <B
CLASS="COMMAND"
>Content-ID</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_description</B
> is the content of the field
              <B
CLASS="COMMAND"
>Content-Description</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_version</B
> is the version of MIME
              in use.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition</B
> is the MIME
              disposition information
              (see <A
HREF="#MAILMIME-DISPOSITION"
>the Section called <I
>mailmime_disposition - MIME disposition information (Content-Disposition)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition_filename</B
> is
              the <B
CLASS="COMMAND"
>filename</B
> parameter of the 
              MIME disposition information.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition_creation_date</B
> is
              the <B
CLASS="COMMAND"
>creation-date</B
> parameter of the 
              MIME disposition information.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition_modification_date</B
> is
              the <B
CLASS="COMMAND"
>modification-date</B
> parameter of the 
              MIME disposition information.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition_read_date</B
> is
              the <B
CLASS="COMMAND"
>read-date</B
> parameter of the 
              MIME disposition information.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_disposition_size</B
> is
              the <B
CLASS="COMMAND"
>size</B
> parameter of the 
              MIME disposition information.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_language</B
> is the language
              of the MIME part
              (see <A
HREF="#MAILMIME-LANGUAGE"
>the Section called <I
>mailmime_language - Language of MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>single_fields</B
> is the structure to fill.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_fields</B
> is the MIME fields list to
              use to fill the <B
CLASS="COMMAND"
>single_fields</B
>.
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmime_single_fields_new()</B
> creates and
          initializes a data structure with a
          value. Structures given as argument are referenced by the created
          object and will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be freed if the
          object is released.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_single_fields_free()</B
> frees
          memory used by the structure and
          substructures will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be
          released. They should be released by
          the application.
        </P
><P
>          <B
CLASS="COMMAND"
>mailimf_single_fields_init()</B
> will
          initialize fill the data structure, using
          the given argument (<B
CLASS="COMMAND"
>fld_fields</B
> and
          <B
CLASS="COMMAND"
>fld_content</B
>). The interesting fields will
          be filled into single_fields.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2177"
></A
><P
><B
>Example 4-15. Creation and display of single fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_single_fields * single_fields;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content_type;

  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();

  /* look at the example in mailmime_content to see how to
     build a mailmime_content */
  content_type = build_mime_content();

  single_fields = mailmime_single_fields_new(mime_fields, content_type);

  /* do the things */

  mailmime_single_fields_free(single_fields);
  mailmime_fields_free(mime_fields);
}

void display_mime_single_fields(struct mailmime_single_fields * single_fields)
{
  if (single_fields-&gt;fld_content != NULL) {
    printf("content type:\n");
    display_mime_content(single_fields-&gt;fld_content);
    printf("\n");
  }
  if (single_fields-&gt;fld_content_charset != NULL) {
    printf("content type charset: %s\n",
      single_fields-&gt;fld_content_charset);
    printf("\n");
  }
  if (single_fields-&gt;fld_content_boundary != NULL) {
    printf("content type boundary: %s\n",
      single_fields-&gt;fld_content_boundary);
    printf("\n");
  }
  if (single_fields-&gt;content_name != NULL) {
    printf("content type name: %s\n", single_fields-&gt;content_name);
    printf("\n");
  }
  if (single_fields-&gt;fld_encoding != NULL) {
    printf("content transfer encoding:\n");
    display_mime_mechanism(single_fields-&gt;fld_encoding);
    printf("\n");
  }
  if (single_fields-&gt;fld_id != NULL) {
    printf("content id: %s\n", single_fields-&gt;fld_id);
    printf("\n");
  }
  if (single_fields-&gt;fld_description != NULL) {
    printf("content description: %s\n", single_fields-&gt;fld_description);
    printf("\n");
  }
  if (single_fields-&gt;fld_version != 0) {
    printf("mime version: %i.%i\n",
      single_fields-&gt;fld_version&gt;&gt; 16,
      single_fields-&gt;fld_version &#38; 0xFFFF);
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition != NULL) {
    printf("content disposition:\n");
    display_mime_disposition(single_fields-&gt;fld_disposition);
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition_filename != NULL) {
    printf("content disposition filename: %s\n",
      single_fields-&gt;fld_disposition_filename);
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition_creation_date != NULL) {
    printf("content disposition creation date: %s\n",
      single_fields-&gt;fld_disposition_creation_date);
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition_modification_date != NULL) {
    printf("content disposition modification date: %s\n",
      single_fields-&gt;fld_disposition_modification_date);
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition_read_date != NULL) {
    printf("content disposition read date: %s\n",
      single_fields-&gt;fld_disposition_read_date;
    printf("\n");
  }
  if (single_fields-&gt;fld_disposition_size != (size_t) -1) {
    printf("content disposition size : %i\n",
      single_fields-&gt;fld_disposition_size);
    printf("\n");
  }
  if (single_fields-&gt;language != NULL) {
    printf("content language:\n");
    display_mime_language(single_fields-&gt;fld_language);
    printf("\n");
  }
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2180"
>Parser functions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMIME-CONTENT-PARSE"
>mailmime_content_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_content_parse(const char * message, size_t length,
			   size_t * index,
			   struct mailmime_content ** result);
        </PRE
><P
>          This function will parse the content of a
          <B
CLASS="COMMAND"
>Content-Type</B
> header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content type.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2203"
></A
><P
><B
>Example 4-16. Parsing MIME content type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Type") == 0) {
                struct mailmime_content * content_type;
                size_t current_index;

                current_index = 0;
	        r = mailmime_content_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;content_type);
	        if (r == MAILIMF_NO_ERROR) {
	          display_mime_content(content_type);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          mailmime_content_free(content_type);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DESCRIPTION-PARSE"
>mailmime_description_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &gt;libetpan/libetpan.h&lt;

int mailmime_description_parse(const char * message, size_t length,
			       size_t * index,
			       char ** result);
        </PRE
><P
>          This will parse the content of
          <B
CLASS="COMMAND"
>Content-Description</B
> MIME header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content description.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>.
              The result string must be freed with
              <B
CLASS="COMMAND"
>free()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2227"
></A
><P
><B
>Example 4-17. Parsing MIME description</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Description") == 0) {
                char * description;
                size_t current_index;

                current_index = 0;
                r = mailmime_description_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;description);
	        if (r == MAILIMF_NO_ERROR) {
	          printf("%s\n", description);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          free(description);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-ENCODING-PARSE"
>mailmime_encoding_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &gt;libetpan/libetpan.h&lt;

int mailmime_encoding_parse(const char * message, size_t length,
			    size_t * index,
			    struct mailmime_mechanism ** result);
        </PRE
><P
>          This function will parse the content of
          <B
CLASS="COMMAND"
>Content-Transfer-Encoding</B
> header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME encoding mechanism.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2251"
></A
><P
><B
>Example 4-18. parsing MIME encoding mechanism</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Transfer-Encoding") == 0) {
                struct mailmime_content * encoding;
                size_t current_index;

                current_index = 0;
                r = mailmime_encoding_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;encoding);
	        if (r == MAILIMF_NO_ERROR) {
                  display_mime_mechanism(encoding);
	          /* do the things */
	          status = EXIT_SUCCESS;
                  mailmime_mechanism_free(encoding);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELD-PARSE"
>mailmime_field_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailmime_field_parse(struct mailimf_optional_field * field,
		     struct mailmime_field ** result);
        </PRE
><P
>          This function will parse a MIME header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>field</B
> is a non-parsed field
              (see <A
HREF="#MAILIMF-OPTIONAL-FIELD"
>the Section called <I
>mailimf_optional_field - non-standard header</I
> in Chapter 3</A
>).
            </P
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-FIELD"
>the Section called <I
>mailmime_field - MIME header field</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2267"
></A
><P
><B
>Example 4-19. parsing MIME header field</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              r = mailmime_field_parse(field-&gt;fld_data.fld_optional_field,
                &amp;mime_fields);
              if (r == MAILIMF_NO_ERROR) {
                display_mime_field(mime_field);
	        mailmime_field_free(mime_field);
	        status = EXIT_SUCCESS;
              }
            }
          }

	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-ID-PARSE"
>mailmime_id_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &gt;libetpan/libetpan.h&lt;

int mailmime_id_parse(const char * message, size_t length,
		      size_t * index, char ** result);
        </PRE
><P
>          This will parse the content of
          <B
CLASS="COMMAND"
>Content-ID</B
> MIME header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content identifier.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>.
              The result string must be freed with
              <B
CLASS="COMMAND"
>free()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2291"
></A
><P
><B
>Example 4-20. Parsing MIME content identifier</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-ID") == 0) {
                char * id;
                size_t current_index;

                current_index = 0;
                r = mailmime_id_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;id);
	        if (r == MAILIMF_NO_ERROR) {
	          printf("%s\n", id);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          free(id);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS-PARSE"
>mailmime_fields_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailmime_fields_parse(struct mailimf_fields * fields,
		      struct mailmime_fields ** result);
        </PRE
><P
>          This function will parse a MIME header fields.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
> is a list of RFC 2822 fields
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
> in Chapter 3</A
>).
            </P
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2307"
></A
><P
><B
>Example 4-21. parsing MIME header fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          struct mailmime_fields * mime_fields;

	  r = mailmime_fields_parse(f, &amp;mime_fields);
          if (r == MAILIMF_NO_ERROR) {
	    display_mime_fields(mime_fields);
	    mailmime_fields_free(mime_fields);
	    status = EXIT_SUCCESS;
          }

	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-VERSION-PARSE"
>mailmime_version_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_version_parse(const char * message, size_t length,
			   size_t * index,
			   uint32_t * result);
        </PRE
><P
>          This will parse the content of
          <B
CLASS="COMMAND"
>MIME-Version</B
> MIME header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME version.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-FIELD"
>the Section called <I
>mailmime_field - MIME header field</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2331"
></A
><P
><B
>Example 4-22. parsing MIME version</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "MIME-Version") == 0) {
                uint32_t version;
                size_t current_index;

                current_index = 0;
                r = mailmime_version_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;version);
	        if (r == MAILIMF_NO_ERROR) {
	          printf("%i.%i\n", version &gt;&gt; 16, version &amp; 0xFFFF);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          free(description);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-PARAMETER-PARSE"
>mailmime_parameter_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_parameter_parse(const char * message, size_t length,
			     size_t * index,
			     struct mailmime_parameter ** result);
        </PRE
><P
>          This will parse a MIME parameter (parameter of
          <B
CLASS="COMMAND"
>Content-Type</B
> or parameter of
          <B
CLASS="COMMAND"
>Content-Disposition</B
>).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME parameter.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-PARAMETER"
>the Section called <I
>mailmime_parameter - MIME type parameter</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2356"
></A
><P
><B
>Example 4-23. parsing a MIME parameter</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define PARAM_STR "foo=bar"

int main(int argc, char ** argv)
{
  int fd;
  int r;
  size_t current_index;
  struct mailmime_parameter * param;
  int status;

  status = EXIT_FAILURE;
  
  current_index = 0;
  r = mailmime_parameter_parse(PARAM_STR, sizeof(PARAM_STR) - 1,
    &amp;current_index, &amp;param);
  if (r == MAILIMF_NO_ERROR) {
    display_mime_parameter(param);
    /* do the things */
    mailmime_parameter_free(param);
    status = EXIT_SUCCESS;
  }

  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-LANGUAGE-PARSE"
>mailmime_language_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_language_parse(const char * message, size_t length,
			    size_t * index,
			    struct mailmime_language ** result);
        </PRE
><P
>          This function will parse the content of a
          <B
CLASS="COMMAND"
>Content-Language</B
> header.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content language.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-LANGUAGE"
>the Section called <I
>mailmime_language - Language of MIME part</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2380"
></A
><P
><B
>Example 4-24. Parsing the MIME content langage</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Language") == 0) {
                struct mailmime_language * lang;
                size_t current_index;

                current_index = 0;
                r = mailmime_id_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;lang);
	        if (r == MAILIMF_NO_ERROR) {
	          display_mime_language(lang);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          free(id);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION-PARSE"
>mailmime_disposition_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_disposition_parse(const char * message, size_t length,
			       size_t * index,
			       struct mailmime_disposition ** result);
        </PRE
><P
>          This function will parse the content of a
          <B
CLASS="COMMAND"
>Content-Disposition</B
> MIME header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content disposition.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-DISPOSITION"
>the Section called <I
>mailmime_disposition - MIME disposition information (Content-Disposition)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2404"
></A
><P
><B
>Example 4-25. Parsing the MIME content disposition</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Disposition") == 0) {
                struct mailmime_disposition * dsp;
                size_t current_index;

                current_index = 0;
                r = mailmime_id_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;dsp);
	        if (r == MAILIMF_NO_ERROR) {
	          display_mime_disposition(dsp);
	          /* do the things */
	          status = EXIT_SUCCESS;
	          free(id);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION-TYPE-PARSE"
>mailmime_disposition_type_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int
mailmime_disposition_type_parse(const char * message, size_t length,
				size_t * index,
				struct mailmime_disposition_type **
                                result);
        </PRE
><P
>          This function will parse the type of MIME content
          disposition.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME content disposition type.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME-DISPOSITION-TYPE"
>the Section called <I
>mailmime_disposition_type - Type of MIME disposition</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2427"
></A
><P
><B
>Example 4-26. parsing a MIME content disposition type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DSP_TYPE_STR "attachment"

int main(int argc, char ** argv)
{
  int fd;
  int r;
  size_t current_index;
  struct mailmime_disposition_type * dsp_type;
  int status;
  
  status = EXIT_FAILURE;
  
  current_index = 0;
  r = mailmime_disposition_type_parse(DSP_TYPE_STR, sizeof(DSP_TYPE_STR) - 1,
    &amp;current_index, &amp;dsp_type);
  if (r == MAILIMF_NO_ERROR) {
    display_mime_disposition_type(dsp_type);
    /* do the things */
    mailmime_disposition_type_free(dsp_type);
    status = EXIT_SUCCESS;
  }

  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-ENCODED-PHRASE-PARSE"
>mailmime_encoded_phrase_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_encoded_phrase_parse(const char * default_fromcode,
    const char * message, size_t length,
    size_t * index, const char * tocode,
    char ** result);
        </PRE
><P
>          This function will decode a MIME encoded header string,
          encoded with RFC 2047.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>default_fromcode</B
> is the default
              code to use for parts of string that are not marked
              with charset.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is the string to decode.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>tocode</B
> is the destination charset
              for decoding.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2455"
></A
><P
><B
>Example 4-27. decoding a MIME encoded header string</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define TEST_STRING "=?iso-8859-1?ab?= =?iso-8859-15?cd?="

int main(int argc, char ** argv)
{
  size_t cur_token;
  char * decoded_subject;

  cur_token = 0;
  mailmime_encoded_phrase_parse("iso-8859-1",
    TEST_STRING, sizeof(TEST_STRING),
    &amp;cur_token, "iso-8859-1", &amp;decoded_subject);

  printf("%s\n", decoded_subject);
  
  /* do the things */

  free(decoded_subject);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-PARSE"
>mailmime_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_parse(const char * message, size_t length,
		   size_t * index, struct mailmime ** result);
        </PRE
><P
>          This will parse a MIME message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string containing
              the MIME message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2478"
></A
><P
><B
>Example 4-28. parsing a MIME message</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailmime * mime;
	size_t current_index;
	
	current_index = 0;
	r = mailmime_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;mime);
	if (r == MAILIMF_NO_ERROR) {
	    display_mime(mime);
	  /* do the things */
	  status = EXIT_SUCCESS;
	  mailmime_free(mime);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-BASE64-BODY-PARSE"
>mailmime_base64_body_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_base64_body_parse(const char * message, size_t length,
			       size_t * index, char ** result,
			       size_t * result_len);
        </PRE
><P
>          This function will parse a body part encoded using base64.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string encoded using
              base64.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              The result must be freed with
              <B
CLASS="COMMAND"
>mmap_string_unref()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2501"
></A
><P
><B
>Example 4-29. Parsing a base64 encoded part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	char * result;
	size_t result_len;
	
	current_index = 0;
	r = mailmime_base64_body_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;result, &amp;result_len);
	if (r == MAILIMF_NO_ERROR) {
	  
	  /* do the things */
	  
	  mailmime_decoded_part_free(mem);
	  status = EXIT_SUCCESS;
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-QUOTED-PRINTABLE-BODY-PARSE"
>mailmime_quoted_printable_body_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_quoted_printable_body_parse(const char * message, size_t length,
					 size_t * index, char ** result,
					 size_t * result_len, int in_header);
        </PRE
><P
>          This function will parse a body part encoded using quoted
          printable.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string encoded using
              quoted printable.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              The result must be freed with
              <B
CLASS="COMMAND"
>mmap_string_unref()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2524"
></A
><P
><B
>Example 4-30. Parsing a quoted printable encoded part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	char * result;
	size_t result_len;
	
	current_index = 0;
	r = mailmime_quoted_printable_body_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;result, &amp;result_len);
	if (r == MAILIMF_NO_ERROR) {
	  
	  /* do the things */
	  
	  mailmime_decoded_part_free(mem);
	  status = EXIT_SUCCESS;
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-BINARY-BODY-PARSE"
>mailmime_binary_body_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_binary_body_parse(const char * message, size_t length,
			       size_t * index, char ** result,
			       size_t * result_len);
        </PRE
><P
>          This function will parse a body part encoded using binary
          (no encoding).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string encoded using
              binary.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              The result must be freed with
              <B
CLASS="COMMAND"
>mmap_string_unref()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2547"
></A
><P
><B
>Example 4-31. Parsing a binary encoded part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	char * result;
	size_t result_len;
	
	current_index = 0;
	r = mailmime_binary_body_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;result, &amp;result_len);
	if (r == MAILIMF_NO_ERROR) {
	  
	  /* do the things */
	  
	  mailmime_decoded_part_free(mem);
	  status = EXIT_SUCCESS;
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-PART-PARSE"
>mailmime_part_parse</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_MECHANISM_ERROR,
  MAILMIME_MECHANISM_7BIT,
  MAILMIME_MECHANISM_8BIT,
  MAILMIME_MECHANISM_BINARY,
  MAILMIME_MECHANISM_QUOTED_PRINTABLE,
  MAILMIME_MECHANISM_BASE64,
  MAILMIME_MECHANISM_TOKEN
};

int mailmime_part_parse(const char * message, size_t length,
			size_t * index,
			int encoding, char ** result, size_t * result_len);
        </PRE
><P
>          This function will parse a body part encoded using a
          given MIME encoding mechanism.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>message</B
> is a string encoded using
              binary.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the size of the given
              string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is a pointer to the start of
              the address in the given string, <B
CLASS="COMMAND"
>(*
              index)</B
> is modified to point at the end of the
              parsed data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>encoding</B
> is a MIME encoding
              mechanism. The value can be
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_7BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_8BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BINARY</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_QUOTED_PRINTABLE</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BASE64</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_TOKEN</B
>
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>result</B
>. The result of the parse
              operation is stored in <B
CLASS="COMMAND"
>(* result)</B
>
              The result must be freed with
              <B
CLASS="COMMAND"
>mmap_string_unref()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2580"
></A
><P
><B
>Example 4-32. Parsing a MIME encoded part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	char * result;
	size_t result_len;
	
	current_index = 0;
	r = mailmime_part_parse(mem, stat_info.st_size, &amp;current_index,
	  MAILMIME_MECHANISM_QUOTED_PRINTABLE, &amp;result, &amp;result_len);
	if (r == MAILIMF_NO_ERROR) {
	  
	  /* do the things */
	  
	  mailmime_decoded_part_free(mem);
	  status = EXIT_SUCCESS;
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2583"
>Rendering of MIME parts</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS-WRITE"
>mailmime_fields_write, mailmime_content_write and
        mailmime_content_type_write</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_fields_write(FILE * f, int * col,
			  struct mailmime_fields * fields);

int mailmime_content_write(FILE * f, int * col,
			   struct mailmime_content * content);

int mailmime_content_type_write(FILE * f, int * col,
				struct mailmime_content * content);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_write</B
> render the MIME
          header fields.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_content_write</B
> render the MIME
          content type header field.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_content_write</B
> render the
          content of the MIME content type header field.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>col</B
> current column is given for wrapping
              purpose in <B
CLASS="COMMAND"
>(* col)</B
>,
              the resulting columns will be returned..
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>f</B
> is the file descriptor. It can be
              stdout for example.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
> is the header fields
              (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>content</B
> is the header fields
              (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2610"
></A
><P
><B
>Example 4-33. rendering MIME header fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_mime * mime_fields;
  int col;

  /* look at the example in mailmime_fields to see how to
     build a mailmime_fields */
  mime_fields = build_mime_fields();

  col = 0;
  mailmime_fields_write(stdout, &amp;col, mime_fields);

  mailmime_fields_free(mime_fields);
}

int main(int argc, char ** argv)
{
  struct mailmime_content * content;
  int col;

  /* look at the example in mailmime_content to see how to
     build a mailmime_fields */
  content = build_mime_content();

  col = 0;
  mailmime_content_write(stdout, &amp;col, mime_fields);

  mailmime_content_free(content);
}

int main(int argc, char ** argv)
{
  struct mailmime_content * content;
  int col;

  /* look at the example in mailmime_content to see how to
     build a mailmime_fields */
  content = build_mime_content();

  col = 0;
  mailmime_content_type_write(stdout, &amp;col, mime_fields);

  mailmime_content_free(content);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-WRITE"
>mailmime_write</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_write(FILE * f, int * col,
		   struct mailmime * build_info);
        </PRE
><P
>          This function will render a MIME message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>col</B
> current column is given for wrapping
              purpose in <B
CLASS="COMMAND"
>(* col)</B
>,
              the resulting columns will be returned..
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>f</B
> is the file descriptor. It can be
              stdout for example.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>build_info</B
> is the MIME message to
              render.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-QUOTED-PRINTABLE-WRITE"
>mailmime_quoted_printable_write
        and mailmime_base64_write</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_quoted_printable_write(FILE * f, int * col, int istext,
    const char * text, size_t size);

int mailmime_base64_write(FILE * f, int * col,
    const char * text, size_t size);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_quoted_printable_write()</B
> will
          render a string to quoted printable.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_base64_write()</B
> will
          render a string to base64.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>col</B
> current column is given for wrapping
              purpose in <B
CLASS="COMMAND"
>(* col)</B
>,
              the resulting columns will be returned..
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>f</B
> is the file descriptor. It can be
              stdout for example.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>text</B
> is the string to render.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>size</B
> is the size of the string to
              render.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2649"
></A
><P
><B
>Example 4-34. render base64 or quoted printable</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  int col;

  col = 0;
  mailmime_quoted_printable_write(stdout, &amp;col,
    "this is a test", 14);
}

#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  int col;

  col = 0;
  mailmime_base64_write(stdout, &amp;col, "this is a test", 14);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DATA-WRITE"
>mailmime_data_write</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_data_write(FILE * f, int * col,
    struct mailmime_data * data,
    int istext);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_data_write</B
> will
          render MIME data.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>col</B
> current column is given for wrapping
              purpose in <B
CLASS="COMMAND"
>(* col)</B
>,
              the resulting columns will be returned..
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>f</B
> is the file descriptor. It can be
              stdout for example.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>data</B
> is the data to render
              (see <A
HREF="#MAILMIME-DATA"
>the Section called <I
>mailmime_data - Content of MIME part</I
></A
>).
            </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2669"
>Creation functions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DISPOSITION-NEW-FILENAME"
>mailmime_disposition_new_filename and
        mailmime_disposition_new_with_data</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_DISPOSITION_TYPE_ERROR,
  MAILMIME_DISPOSITION_TYPE_INLINE,
  MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
  MAILMIME_DISPOSITION_TYPE_EXTENSION
};

struct mailmime_disposition *
mailmime_disposition_new_filename(int type, char * filename);

struct mailmime_disposition *
mailmime_disposition_new_with_data(int type,
    char * filename, char * creation_date, char * modification_date,
    char * read_date, size_t size);
        </PRE
><P
>          These functions will create a MIME content disposition
          information.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>type</B
> a standard MIME disposition :
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_INLINE</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_ATTACHMENT</B
>.
            </P
><P
>              <B
CLASS="COMMAND"
>filename</B
> is the filename.
            </P
><P
>              <B
CLASS="COMMAND"
>creation_date</B
> is the creation date.
            </P
><P
>              <B
CLASS="COMMAND"
>modification_date</B
> is the modification
              date.
            </P
><P
>              <B
CLASS="COMMAND"
>read_date</B
> is the last read date.
            </P
><P
>              <B
CLASS="COMMAND"
>size</B
> is the size of the file.
            </P
></LI
><LI
><P
>              This will return a MIME content disposition
              (see <A
HREF="#MAILMIME-DISPOSITION"
>the Section called <I
>mailmime_disposition - MIME disposition information (Content-Disposition)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2694"
></A
><P
><B
>Example 4-35. creating a MIME content disposition</B
></P
><PRE
CLASS="PROGRAMLISTING"
>        
#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_disposition * disposition;

  disposition =
    mailmime_disposition_new_filename(MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
      strdup("foo-bar.txt"));

  /* do the things */
  
  mailmime_disposition_free(disposition);
}
        </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS-NEW-EMPTY"
>mailmime_fields_new_empty and mailmime_fields_add</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_fields * mailmime_fields_new_empty(void);

int mailmime_fields_add(struct mailmime_fields * fields,
			struct mailmime_field * field);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new_empty()</B
> will
          create a new empty MIME header fields list.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_add()</B
> will add
          MIME header fields to the MIME header fields list.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
>. The MIME header field will
              be added to this MIME header fields list
              (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>field</B
> is the MIME header field to add
              (see <A
HREF="#MAILMIME-FIELD"
>the Section called <I
>mailmime_field - MIME header field</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2713"
></A
><P
><B
>Example 4-36. creating a MIME header fields list</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_fields * fields;
  struct mailmime_field * field;

  fields = mailmime_fields_new_empty();
  field = build_mime_field();
  
  /* do the things */

  mailmime_fields_add(fields, field);
  
  mailmime_fields_free(fields);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS-NEW-WITH-DATA"
>mailmime_fields_new_with_data and
        mailmime_fields_new_with_version</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_fields *
mailmime_fields_new_with_data(struct mailmime_mechanism * encoding,
			      char * id,
			      char * description,
			      struct mailmime_disposition * disposition,
			      struct mailmime_language * language);

struct mailmime_fields *
mailmime_fields_new_with_version(struct mailmime_mechanism * encoding,
				 char * id,
				 char * description,
				 struct mailmime_disposition * disposition,
				 struct mailmime_language * language);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new_with_data()</B
> will
          create a MIME header fields list with all the given fields
          (<B
CLASS="COMMAND"
>NULL</B
> can be used for the value if the
          field must not be present).
          <B
CLASS="COMMAND"
>MIME-Version</B
> header field will
          <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> be added.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new_with_version()</B
> will
          create a MIME header fields list with all the given fields
          (<B
CLASS="COMMAND"
>NULL</B
> can be used for the value if the
          field must not be present).
          <B
CLASS="COMMAND"
>MIME-Version</B
> header field will be added.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2728"
></A
><P
><B
>Example 4-37. creating new fields</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_disposition * disposition;
  struct mailmime_fields * mime_fields;
  struct mailmime_mechanism * encoding;
  
  encoding = mailmime_mechanism_new(MAILMIME_MECHANISM_BASE64, NULL);
  
  disposition =
    mailmime_disposition_new_filename(MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
      strdup("foo-bar.txt"));
  
  mime_fields = mailmime_fields_new_with_version(encoding, NULL,
    NULL, disposition, NULL);
  
  /* do the things */
  
  mailmime_fields_free(mime_fields);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-GET-CONTENT-MESSAGE"
>mailmime_get_content_message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime_content * mailmime_get_content_message(void);

struct mailmime_content * mailmime_get_content_text(void);

struct mailmime_content * mailmime_content_new_with_str(const char * str);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_get_content_message()</B
> will
          create a MIME content type
          <B
CLASS="COMMAND"
>message/rfc822</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_get_content_text()</B
> will
          create a MIME content type
          <B
CLASS="COMMAND"
>plain/text</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_get_content_new_with_str()</B
> will
          create a MIME content type given by the string
          <B
CLASS="COMMAND"
>plain/text</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>str</B
>. This string will 
          <B
CLASS="COMMAND"
>NOT</B
> be referenced by any structure.
          This string will only be parsed to create the structure.
        </P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2746"
></A
><P
><B
>Example 4-38. Creating a MIME content type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime_content * content;
  
  content = mailmime_get_content_message();
  
  /* do the things */
  
  mailmime_content_free(content);
}

int main(int argc, char ** argv)
{
  struct mailmime_content * content;
  
  content = mailmime_get_content_text();
  
  /* do the things */
  
  mailmime_content_free(content);
}

int main(int argc, char ** argv)
{
  struct mailmime_content * content;
  
  content = mailmime_get_content_new_with_str("multipart/mixed");
  
  /* do the things */
  
  mailmime_content_free(content);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-DATA-NEW-DATA"
>mailmime_data_new_data and mailmime_data_new_file</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_MECHANISM_ERROR,
  MAILMIME_MECHANISM_7BIT,
  MAILMIME_MECHANISM_8BIT,
  MAILMIME_MECHANISM_BINARY,
  MAILMIME_MECHANISM_QUOTED_PRINTABLE,
  MAILMIME_MECHANISM_BASE64,
  MAILMIME_MECHANISM_TOKEN
};

struct mailmime_data *
mailmime_data_new_data(int encoding, int encoded,
		       const char * data, size_t length);

struct mailmime_data *
mailmime_data_new_file(int encoding, int encoded,
		       char * filename);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_data_new_data()</B
> will create a
          new MIME content, using a string in memory.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_data_new_file()</B
> will create a
          new MIME content, using a file.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>encoding</B
> is the MIME encoding 
              mechanism used to encode this part. The value can be
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_7BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_8BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BINARY</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_QUOTED_PRINTABLE</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BASE64</B
>
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>encoded</B
> is set to 1 if the part is 
              already encoded with the mechanism given in
              <B
CLASS="COMMAND"
>encoding</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>data</B
> is a pointer to the
              content of the part.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the length of the data.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>filename</B
> is the name of the file.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2779"
></A
><P
><B
>Example 4-39. creating MIME content</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DATA_STR "my data"

int main(int argc, char ** argv)
{
  struct mailmime_data * data;
  
  data = mailmime_data_new_data(MAILMIME_MECHANISM_BASE64, 0,
		                DATA_STR, sizeof(DATA_STR) - 1);

  /* do the things */
  
  mailmime_data_free(data);
}

int main(int argc, char ** argv)
{
  struct mailmime_data * data;
  
  data = mailmime_data_new_file(MAILMIME_MECHANISM_BASE64, 0,
		                strdup("foo-bar.txt"));

  /* do the things */
  
  mailmime_data_free(data);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-NEW-MESSAGE-DATA"
>mailmime_new_message_data, mailmime_new_empty and
        mailmime_new_with_content</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmime *
mailmime_new_message_data(struct mailmime * msg_mime);

struct mailmime *
mailmime_new_empty(struct mailmime_content * content,
		   struct mailmime_fields * mime_fields);

int
mailmime_new_with_content(const char * content_type,
			  struct mailmime_fields * mime_fields,
			  struct mailmime ** result);

struct mailmime * mailmime_multiple_new(const char * type);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_new_message_data()</B
> will create a
          new MIME message with the given subpart.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_new_empty()</B
> will create a
          new MIME part with the given content type and MIME fields
          but with no content.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_new_with_content()</B
> will create a
          new MIME part with a content type given by a string and a
          given MIME fields list.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_multiple_new()</B
> will create a
          new MIME multipart with a content type given by a string.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>msg_mime</B
> is the sub part to add to the
              MIME message when creating it
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>content</B
> is the content type of the part
              to create
              (see <A
HREF="#MAILMIME-CONTENT"
>the Section called <I
>mailmime_content - MIME content type (Content-Type)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>content_type</B
> is the content type of
              the part to create given by a string.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mime_fields</B
> is the list of MIME
              header fields
              (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2809"
></A
><P
><B
>Example 4-40. creating a MIME part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DATA_STR "my data"

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailmime * single_part;
  
  mime_fields =
    mailmime_fields_new_encoding(MAILMIME_MECHANISM_QUOTED_PRINTABLE);
  mailmime_new_with_content("plain/text", mime_fields, &amp;single_part);

  mailmime_set_body_text(single_part, DATA_STR, sizeof(DATA_STR) - 1);

  mime = mailmime_new_message_data(single_part);

  /* do the things */
  
  mailmime_free(mime);
}

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailmime * single_part;
  struct mailmime_content * content;
  
  mime_fields =
    mailmime_fields_new_encoding(MAILMIME_MECHANISM_QUOTED_PRINTABLE);
  content = mailmime_get_content_text();
  single_part = mailmime_new_empty(content, mime_fields);

  mailmime_set_body_text(single_part, DATA_STR, sizeof(DATA_STR) - 1);

  mime = mailmime_new_message_data(single_part);

  /* do the things */
  
  mailmime_free(mime);
}

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  
  mime = mailmime_multiple_new("multipart/mixed");

  /* do the things */
  
  mailmime_free(mime);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-SET-PREAMBLE-FILE"
>mailmime_set_preamble_file, mailmime_set_epilogue_file,
        mailmime_set_preamble_text and mailmime_set_epilogue_text</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_set_preamble_file(struct mailmime * build_info,
			       char * filename);

int mailmime_set_epilogue_file(struct mailmime * build_info,
			       char * filename);

int mailmime_set_preamble_text(struct mailmime * build_info,
			       char * data_str, size_t length);

int mailmime_set_epilogue_text(struct mailmime * build_info,
			       char * data_str, size_t length);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_set_preamble_file()</B
> will define
          the preamble of a multipart.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_set_preamble_text()</B
> will define
          the preamble of a multipart.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_set_epilogue_file()</B
> will define
          the epilogue of a multipart.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_set_preamble_text()</B
> will define
          the preamble of a multipart.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>build_info</B
> is the MIME part to modify
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>data_str</B
> is the string to define
              as epilogue or prologue.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the length of the string to
              define as epilogue or prologue.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>filename</B
> is the name of the file
              which content will be defined as epilogue or prologue.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2837"
></A
><P
><B
>Example 4-41. setting preamble and epilogue</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DATA_STR "test foo bar"

int main(int argc, char ** argv)
{
  struct mailmime * mime;

  mime = mailmime_multiple_new("multipart/mixed");  

  mailmime_set_preamble_file(mime, strdup("foo-bar.txt"));

  mailmime_set_epilogue_data(mime, DATA_STR, sizeof(DATA_STR) - 1);

  /* do the things */

  mailmime_free(mime);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-SET-BODY-FILE"
>mailmime_set_body_file and mailmime_set_body_text</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_set_body_file(struct mailmime * build_info,
			   char * filename);

int mailmime_set_body_text(struct mailmime * build_info,
			   char * data_str, size_t length);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_set_body_file()</B
> will define
          the body of a single part.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_set_body_text()</B
> will define
          the body of a single part.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>build_info</B
> is the MIME part to modify
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>data_str</B
> is the string to define
              as the body of the part.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>length</B
> is the length of the string to
              define as the body of the part.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>filename</B
> is the name of the file
              which content will be defined as the body of the part.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2861"
></A
><P
><B
>Example 4-42. creating a MIME part</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DATA_STR "my data"

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  
  mime_fields =
    mailmime_fields_new_encoding(MAILMIME_MECHANISM_QUOTED_PRINTABLE);
  mailmime_new_with_content("plain/text", mime_fields, &amp;mime);

  mailmime_set_body_text(mime, DATA_STR, sizeof(DATA_STR) - 1);

  

  /* do the things */
  
  mailmime_free(mime);
}
        </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-ADD-PART"
>mailmime_add_part, mailmime_remove_part,
        mailmime_smart_add_part and mailmime_smart_remove_part</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_add_part(struct mailmime * build_info,
		      struct mailmime * part);

void mailmime_remove_part(struct mailmime * mime);

int mailmime_smart_add_part(struct mailmime * mime,
    struct mailmime * mime_sub);

int mailmime_smart_remove_part(struct mailmime * mime);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_add_part()</B
> will add a sub MIME
          part.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_remove_part()</B
> will detach the
          given sub part from its parent.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_smart_add_part()</B
> will add a sub
          MIME part. If the parent part is a message and no child
          exist, the part is set as the child. If the parent part is a
          message and a child already exists, if the child is
          multipart, the part to add is added as child of this
          multipart, else a multipart is added and the part is added
          as child of the multipart.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_smart_remove_part()</B
> will detach
          the given sub part from its parent. The sub part will be
          freed.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>build_info</B
> is the parent MIME part
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>part</B
> is the part to add
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mime</B
> is the parent MIME part
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>mime_sub</B
> is the part to add or to
              detach
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2892"
></A
><P
><B
>Example 4-43. modifying MIME structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(int argc, char ** argv)
{
  struct mailmime * sub_mime;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content;

  content = mailmime_get_content_text();
  
  mime_fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_BASE64);
  
  sub_mime = mailmime_new_empty(content, mime_fields);

  mime = mailmime_new_message_data(NULL);

  mailmime_add_part(mime, sub_mime);
  
  /* do the things */

  mailmime_free(mime);

int main(int argc, char ** argv)
{
  struct mailmime * sub_mime;
  struct mailmime * other_sub_mime;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content;

  content = mailmime_get_content_text();
  mime_fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_BASE64);
  sub_mime = mailmime_new_empty(content, mime_fields);

  content = mailmime_get_content_text();
  mime_fields =
    mailmime_fields_new_encoding(MAILMIME_MECHANISM_QUOTED_PRINTABLE);
  other_sub_mime = mailmime_new_empty(content, mime_fields);

  mime = mailmime_new_message_data(NULL);

  mailmime_smart_add_part(mime, sub_mime);
  mailmime_smart_add_part(mime, other_sub_mime);
  
  /* do the things */

  mailmime_free(mime);

int main(int argc, char ** argv)
{
  struct mailmime * sub_mime;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content;

  content = mailmime_get_content_text();
  
  mime_fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_BASE64);
  
  sub_mime = mailmime_new_empty(content, mime_fields);

  mime = mailmime_new_message_data(NULL);

  mailmime_add_part(mime, sub_mime);

  mailmime_remove_part(sub_mime);
  
  /* do the things */

  mailmime_free(sub_mime);
  mailmime_free(mime);

int main(int argc, char ** argv)
{
  struct mailmime * sub_mime;
  struct mailmime_fields * mime_fields;
  struct mailmime_content * content;

  content = mailmime_get_content_text();
  
  mime_fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_BASE64);
  
  sub_mime = mailmime_new_empty(content, mime_fields);

  mime = mailmime_new_message_data(NULL);

  mailmime_add_part(mime, sub_mime);

  mailmime_smart_remove_part(sub_mime);
  
  /* do the things */

  mailmime_free(mime);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-SET-IMF-FIELDS"
>mailmime_set_imf_fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

void mailmime_set_imf_fields(struct mailmime * build_info,
    struct mailimf_fields * fields);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_set_imf_fields()</B
> will set the
          fields of the given MIME message.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>build_info</B
> is the MIME message to
              modify
              (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
> is the header fields to set
              for the message
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
> in Chapter 3</A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2909"
></A
><P
><B
>Example 4-44. modifying MIME structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DATA_STR "test foo bar"

int main(int argc, char ** argv)
{
  struct mailmime * mime;
  struct mailmime_fields * mime_fields;
  struct mailimf_fields * imf_fields;

  mime_fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_8BIT);

  mailmime_new_with_content("text/plain", mime_fields, &amp;mime);

  mailmime_set_body_text(mime, DATA_STR, sizeof(DATA_STR) - 1);

  /* look at the example in mailimf_fields to see how to
     build a mailimf_fields */
  imf_fields = build_fields();

  mailmime_set_imf_fields(mime, imf_fields);

  /* do the things */

  mailmime_free(mime);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-FIELDS-NEW-ENCODING"
>mailmime_fields_new_encoding and
        mailmime_fields_new_filename</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAILMIME_MECHANISM_ERROR,
  MAILMIME_MECHANISM_7BIT,
  MAILMIME_MECHANISM_8BIT,
  MAILMIME_MECHANISM_BINARY,
  MAILMIME_MECHANISM_QUOTED_PRINTABLE,
  MAILMIME_MECHANISM_BASE64,
  MAILMIME_MECHANISM_TOKEN
};

enum {
  MAILMIME_DISPOSITION_TYPE_ERROR,
  MAILMIME_DISPOSITION_TYPE_INLINE,
  MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
  MAILMIME_DISPOSITION_TYPE_EXTENSION
};

struct mailmime_fields * mailmime_fields_new_encoding(int encoding_type);

struct mailmime_fields * mailmime_fields_new_filename(int dsp_type,
    char * filename, int encoding_type);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new_encoding()</B
> will
          create a list of MIME header fields with only
          <B
CLASS="COMMAND"
>Content-Transfer-Encoding</B
>.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_fields_new_filename()</B
> will
          create a list of MIME header fields with
          <B
CLASS="COMMAND"
>Content-Transfer-Encoding</B
> and
          <B
CLASS="COMMAND"
>Content-Disposition</B
>.
        </P
><P
>          The result will be a list of MIME header fields
          (see <A
HREF="#MAILMIME-FIELDS"
>the Section called <I
>mailmime_fields - header fields</I
></A
>).
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>encoding_type</B
> is the MIME encoding
              mechanism. The value can be 
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_7BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_8BIT</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BINARY</B
>,
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_QUOTED_PRINTABLE</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_MECHANISM_BASE64</B
>
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>dsp_type</B
> is the disposition type.
              The value can be 
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_INLINE</B
> or
              <B
CLASS="COMMAND"
>MAILMIME_DISPOSITION_TYPE_ATTACHMENT</B
>
              (see <A
HREF="#MAILMIME-DISPOSITION-TYPE"
>the Section called <I
>mailmime_disposition_type - Type of MIME disposition</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>filename</B
> is the filename for MIME
              content disposition.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2943"
></A
><P
><B
>Example 4-45. creating MIME fields with only Content-Transfer-Encoding</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int main(void)
{
  struct mailmime_fields * fields;

  fields = mailmime_fields_new_encoding(MAILMIME_MECHANISM_BASE64);
  
  /* do the things */
  
  mailmime_fields_free(fields);
}

int main(void)
{
  struct mailmime_fields * fields;

  fields =
  mailmime_fields_new_filename(MAILMIME_DISPOSITION_TYPE_ATTACHMENT,
    strdup("foo-bar.txt"), MAILMIME_MECHANISM_BASE64);
  
  /* do the things */
  
  mailmime_fields_free(fields);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2946"
>Helper functions</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMIME-TRANSFER-ENCODING-GET"
>mailmime_transfer_encoding_get</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmime_transfer_encoding_get(struct mailmime_fields * fields);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_transfer_encoding_get()</B
> will
          return the standard MIME encoding mechanism.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fields</B
> is the list of MIME header
              fields.
            </P
></LI
><LI
><P
>              An integer representing the MIME encoding mechanism will
              be returned
              (see <A
HREF="#MAILMIME-MECHANISM"
>the Section called <I
>mailmime_mechanism - MIME transfer encoding mechanism (Content-Transfer-Encoding)</I
></A
>).
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2960"
></A
><P
><B
>Example 4-46. extracting MIME encoding mechanism</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          struct mailmime_fields * mime_fields;

	  r = mailmime_fields_parse(f, &amp;mime_fields);
          if (r == MAILIMF_NO_ERROR) {
            int encoding;
            
            encoding = mailmime_transfer_encoding_get(mime_fields);
            
            /* do the things */
            
	    mailmime_fields_free(mime_fields);
	    status = EXIT_SUCCESS;
          }

	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMIME-CONTENT-CHARSET-GET"
>mailmime_content_charset_get and
        mailmime_content_param_get</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

char * mailmime_content_charset_get(struct mailmime_content * content);

char * mailmime_content_param_get(struct mailmime_content * content,
				  char * name);

char * mailmime_extract_boundary(struct mailmime_content * content_type);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmime_content_charset_get()</B
> will
          return the <B
CLASS="COMMAND"
>charset</B
> parameter of
          MIME content type.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_content_param_get()</B
> will
          return the value of a given parameter of
          MIME content type.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmime_extract_boundary()</B
> will
          return the <B
CLASS="COMMAND"
>charset</B
> parameter of
          MIME content type.
        </P
><P
></P
><UL
><LI
><P
> 
              <B
CLASS="COMMAND"
>content</B
> is the MIME content type.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>name</B
> is the name of the parameter to
              extract.
            </P
></LI
><LI
><P
>              With <B
CLASS="COMMAND"
>mailmime_extract_boundary()</B
>, the
              returned value must be freed with
              <B
CLASS="COMMAND"
>free()</B
>.
            </P
></LI
></UL
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN2985"
></A
><P
><B
>Example 4-47. extracting information from MIME content type</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char ** argv)
{
  int fd;
  int r;
  
  status = EXIT_FAILURE;
  
  fd = open("message.rfc2822", O_RDONLY);
  if (fd &gt;= 0) {
    void * mem;
    struct stat stat_info;
    
    r = fstat(fd, &amp;stat_info);
    if (r &gt;= 0) {
      mem = mmap(NULL, stat_info.st_size, PROT_READ, MAP_PRIVATE);
      if (mem != MAP_FAILED) {
        struct mailimf_fields * f;
	size_t current_index;
	
	current_index = 0;
	r = mailimf_fields_parse(mem, stat_info.st_size,
          &amp;current_index, &amp;f);
	if (r == MAILIMF_NO_ERROR) {
          clistiter * cur;
        
          for(cur = clist_begin(f-&gt;fld_list) ; cur != NULL ; cur =
            clist_next(cur)) {
            struct mailmime_field * mime_field;
            struct mailimf_field * field;
            
            field = clist_content(cur);
            
            if (field-&gt;fld_type == MAILIMF_FIELD_OPTIONAL_FIELD) {
              if (strcasecmp(field-&gt;fld_data.fld_optional_field-&gt;fld_name,
                "Content-Type") == 0) {
                struct mailmime_content * content_type;
                size_t current_index;

                current_index = 0;
	        r = mailmime_content_parse(field-&gt;fld_data.fld_optional_field-&gt;fld_value,
                  strlen(field-&gt;fld_data.fld_optional_field-&gt;fld_value),
                  &amp;current_index, &amp;content_type);
	        if (r == MAILIMF_NO_ERROR) {
                  char * charset;
                  char * name;
                  char * boundary;                  

                  charset = mailmime_content_charset_get(content_type);
                  name = mailmime_content_param_get(content_type, "name");
                  boundary = mailmime_extract_boundary(content_type);
                  
	          /* do the things */
                  
                  free(boundary);
                  
	          status = EXIT_SUCCESS;
	          mailmime_content_free(content_type);
	        }
              }
            }
          }
	  mailimf_fields_free(f);
	}
      }
      munmap(mem, stat_info.st_size);
    }
    
    close(fd);
  }
  
  exit(status);
}
          </PRE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN2988"
></A
>Chapter 5. Storages, folders, messages</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2990"
>Introduction</A
></H2
><P
>        This part will give the definition of some objects.
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2993"
>Message</A
></H3
><P
>          A message is the common e-mail message or news message you
          read or send.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2996"
>MIME part</A
></H3
><P
>          A message can have attachment such as images or other documents.
          The attachment are organized into a tree structure. Each
          node of this structure is a MIME part.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2999"
>Mailbox</A
></H3
><P
>          A mailbox will contain a given number of messages.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3002"
>Storage</A
></H3
><P
>          A storage is a "physical" localisation of your mailbox. This
          can be on a filesystem (local or remote disk, this is the
          case of MH, mbox and maildir), or this can be on a remote
          host (this is the case for POP3, IMAP or NNTP).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3005"
>Folder</A
></H3
><P
>          A storage, for the same user, can contain a given number of
          mailboxes, depending the storage capabilities, then, the
          storage driver capabilities. With etPan!, MH, IMAP and NNTP
          storages can have more than one mailbox. The mailboxes will
          be called folders. On storage where we only have one
          mailbox, the unique mailbox is the unique folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3008"
>Session</A
></H3
><P
>          The session is the network connection or the entity to which
          the commands of the drivers are given.
        </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3011"
>Error codes</A
></H2
><P
>        Error codes returned as integers can be one of the following :
      </P
><PRE
CLASS="PROGRAMLISTING"
>enum {
  MAIL_NO_ERROR = 0,
  MAIL_NO_ERROR_AUTHENTICATED,
  MAIL_NO_ERROR_NON_AUTHENTICATED,
  MAIL_ERROR_NOT_IMPLEMENTED,
  MAIL_ERROR_UNKNOWN,
  MAIL_ERROR_CONNECT,
  MAIL_ERROR_BAD_STATE,
  MAIL_ERROR_FILE,
  MAIL_ERROR_STREAM,
  MAIL_ERROR_LOGIN,
  MAIL_ERROR_CREATE, /* 10 */
  MAIL_ERROR_DELETE,
  MAIL_ERROR_LOGOUT,
  MAIL_ERROR_NOOP,
  MAIL_ERROR_RENAME,
  MAIL_ERROR_CHECK,
  MAIL_ERROR_EXAMINE,
  MAIL_ERROR_SELECT,
  MAIL_ERROR_MEMORY,
  MAIL_ERROR_STATUS,
  MAIL_ERROR_SUBSCRIBE, /* 20 */
  MAIL_ERROR_UNSUBSCRIBE,
  MAIL_ERROR_LIST,
  MAIL_ERROR_LSUB,
  MAIL_ERROR_APPEND,
  MAIL_ERROR_COPY,
  MAIL_ERROR_FETCH,
  MAIL_ERROR_STORE,
  MAIL_ERROR_SEARCH,
  MAIL_ERROR_DISKSPACE,
  MAIL_ERROR_MSG_NOT_FOUND,  /* 30 */
  MAIL_ERROR_PARSE,
  MAIL_ERROR_INVAL,
  MAIL_ERROR_PART_NOT_FOUND,
  MAIL_ERROR_REMOVE,
  MAIL_ERROR_FOLDER_NOT_FOUND,
  MAIL_ERROR_MOVE,
  MAIL_ERROR_STARTTLS,
  MAIL_ERROR_CACHE_MISS,
  MAIL_ERROR_NO_TLS,
  MAIL_ERROR_EXPUNGE,
  /* misc errors */
  MAIL_ERROR_MISC,
  MAIL_ERROR_PROTOCOL,
  MAIL_ERROR_CAPABILITY,
  MAIL_ERROR_CLOSE,
  MAIL_ERROR_FATAL,
  MAIL_ERROR_READONLY,
  MAIL_ERROR_NO_APOP,
  MAIL_ERROR_COMMAND_NOT_SUPPORTED,
  MAIL_ERROR_NO_PERMISSION,
  MAIL_ERROR_PROGRAM_ERROR,
  MAIL_ERROR_SUBJECT_NOT_FOUND,
  MAIL_ERROR_CHAR_ENCODING_FAILED,
  MAIL_ERROR_SEND,
  MAIL_ERROR_COMMAND,
};
      </PRE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3015"
>Storage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILSTORAGE-DRIVER"
>Storage driver</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

typedef struct mailstorage_driver mailstorage_driver;

struct mailstorage_driver {
  char * sto_name;
  int (* sto_connect)(struct mailstorage * storage);
  int (* sto_get_folder_session)(struct mailstorage * storage,
      char * pathname, mailsession ** result);
  void (* sto_uninitialize)(struct mailstorage * storage);
};
        </PRE
><P
>          This is the driver for a storage.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sto_name</B
> is the name of the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_connect()</B
> connects the storage to
              the remote access or to the path in the local filesystem.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_get_folder_session()</B
> can have two
              kinds of behaviour. Either it creates a new session and
              independant from the session used by the storage and
              select the given mailbox or it selects the given mailbox
              in the current session. It depends on the efficiency of
              the mail access.
            </P
><P
>              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>XXX - in the future, this will be moved to the
              folder driver</I
></SPAN
>
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_uninitialize()</B
> frees the data
              created with mailstorage constructor.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSTORAGE"
>Storage</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailstorage {
  char * sto_id;
  void * sto_data;
  mailsession * sto_session;
  mailstorage_driver * sto_driver;
  clist * sto_shared_folders; /* list of (struct mailfolder *) */
  
  void * sto_user_data;
};
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sto_id</B
> is an identifier for the
              storage. This can be <B
CLASS="COMMAND"
>NULL</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_data</B
> is the internal data
              of the storage. This can only be changed by the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_session</B
> is the session used by
              the storage. The session can be used to send commands.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_driver</B
> is the driver of the
              storage.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_shared_folders</B
> is the list of
              folders that share the session with the storage.
              This is used internally.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sto_user_data</B
> is a field for free
              use. The user can store any data in that field.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSTORAGE-NEW"
>mailstorage_new and mailstorage_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailstorage * mailstorage_new(char * sto_id);

void mailstorage_free(struct mailstorage * storage);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailstorage_new()</B
> initializes a storage
          structure with an identifier (<B
CLASS="COMMAND"
>sto_id</B
>) and
          with no driver.
        </P
><P
>          <B
CLASS="COMMAND"
>mailstorage_free()</B
> free the memory used
          by a storage.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSTORAGE-CONNECT"
>mailstorage_connect and mailstorage_disconnect</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailstorage_connect(struct mailstorage * storage);

void mailstorage_disconnect(struct mailstorage * storage);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailstorage_connect()</B
> connects the storage.
          This function can also be used to confirm that a storage
          connection is valid when the storage is already connected.
        </P
><P
>          <B
CLASS="COMMAND"
>mailstorage_disconnect()</B
> disconnects the 
          storage.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3074"
>IMAP storage</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int imap_mailstorage_init(struct mailstorage * storage,
    char * imap_servername, uint16_t imap_port,
    char * imap_command,
    int imap_connection_type, int imap_auth_type,
    char * imap_login, char * imap_password,
    int imap_cached, char * imap_cache_directory);
        </PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3077"
>Example</A
></H3
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN3079"
></A
><P
><B
>Example 5-1. use of storage</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(void)
{
  struct mailstorage * storage;
  int r;

  storage = mailstorage_new(NULL);
  
  imap_mailstorage_init(storage, "imap.my-servers.org", 0,
    NULL, CONNECTION_TYPE_TRY_STARTTLS, IMAP_AUTH_TYPE_PLAIN,
    "my-login", "my-password", 1, "/home/login/.libetpan/cache");

  r = mailstorage_connect(storage);
  if (r == MAIL_NO_ERROR) {
    mailstorage_disconnect(storage);
  }
  
  mailstorage_free(storage);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3082"
>Folder</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-DRIVER"
>Folder driver</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

typedef struct mailfolder_driver mailfolder_driver;

struct mailfolder_driver {
  int (* fld_get_session)(struct mailfolder * folder,
    mailsession ** result);

  int (* fld_noop)(struct mailfolder * folder);

  int (* fld_check)(struct mailfolder * folder);

  int (* fld_expunge)(struct mailfolder * folder);

  int (* fld_status)(struct mailfolder * folder,
    uint32_t * result_messages, uint32_t * result_recent,
    uint32_t * result_unseen);

  int (* fld_append_message)(struct mailfolder * folder,
    char * message, size_t size);

  int (* fld_get_messages_list)(struct mailfolder * folder,
    struct mailmessage_list ** result);

  int (* fld_get_envelopes_list)(struct mailfolder * folder,
    struct mailmessage_list * result);

  int (* fld_get_message)(struct mailfolder * folder,
    uint32_t num, mailmessage ** result);

  int (* fld_get_message_by_uid)(struct mailfolder * folder,
    const char * uid, mailmessage ** result);
}
        </PRE
><P
>          XXX - this will be implemented in the future.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_get_session()</B
> will return the session
              this folder should use.
              </P
></LI
><LI
><P
>              For other method, you should see <A
HREF="#MAILSESSION-DRIVER"
>the Section called <I
>Session driver</I
></A
>.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3095"
>Folder</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailfolder {
  char * fld_pathname;
  char * fld_virtual_name;
  
  struct mailstorage * fld_storage;

  mailsession * fld_session;
  int fld_shared_session;
  clistiter * fld_pos;

  struct mailfolder * fld_parent;
  unsigned int fld_sibling_index;
  carray * fld_children; /* array of (struct mailfolder *) */

  void * fld_user_data;
};
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fld_pathname</B
> is the pathname specific to
              the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_virtual_name</B
> is the identifier of
              this folder. This can be <B
CLASS="COMMAND"
>NULL</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_storage</B
> is the storage used for this
              folder (see <A
HREF="#MAILSTORAGE"
>the Section called <I
>Storage</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_session</B
> is the session used for this
              folder.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_shared_session</B
> is set to 1 if the
              folder use the same session as the storage. This is used
              internally.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_pos</B
> is the 
              position in the list of folders of the storage.
              This is used internally.
            </P
></LI
><LI
><P
>              use of <B
CLASS="COMMAND"
>fld_parent</B
>,
              <B
CLASS="COMMAND"
>fld_sibling_index</B
> and
              <B
CLASS="COMMAND"
>fld_children</B
> is deprecated.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fld_user_data</B
> is a field for free
              use. The user can store any data in that field.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-NEW"
>mailfolder_new and mail_folder_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailfolder * mailfolder_new(struct mailstorage * fld_storage,
    char * fld_pathname, char * fld_virtual_name);

void mailfolder_free(struct mailfolder * folder);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailfolder_new()</B
> initializes a folder
          structure with an identifier
          (<B
CLASS="COMMAND"
>fld_virtual_name</B
>) with path name
          (<B
CLASS="COMMAND"
>fld_pathname</B
>). The folder will be owned
          by the given storage (<B
CLASS="COMMAND"
>fld_storage</B
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailfolder_free()</B
> free the memory used
          by the folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-CONNECT"
>mailfolder_connect and mailfolder_disconnect</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailfolder_connect(struct mailfolder * folder);

void mailfolder_disconnect(struct mailfolder * folder);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailfolder_connect()</B
> connects the folder.
          This function can also be used to confirm that a folder
          connection is valid when the folder is already connected.
          When doing operations with several folders, you have to be
          sure that this function has been called before making calls
          on folder.
        </P
><P
>          <B
CLASS="COMMAND"
>mailfolder_disconnect()</B
> disconnects the 
          folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-NOOP"
>mailfolder_noop</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailfolder_noop(struct mailfolder * folder);
        </PRE
><P
>          This function will only send noop to the mail access.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-CHECK"
>mailfolder_check</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailfolder_check(struct mailfolder * folder);
        </PRE
><P
>          A call to this function will save to disk the internal state
          of the selected mailbox (such as flags).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-EXPUNGE"
>mailfolder_expunge</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailfolder_expunge(struct mailfolder * folder);
        </PRE
><P
>          A call to this function will delete all messages marked for
          deletion.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-STATUS"
>mailfolder_status</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_status(struct mailfolder * folder,
    uint32_t * result_messages, uint32_t * result_recent,
    uint32_t * result_unseen);
        </PRE
><P
>          A call to this function will return some counts of messages
          in the mailbox.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-APPEND-MESSAGE"
>mailfolder_append_message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_append_message(struct mailfolder * folder,
    char * message, size_t size);
        </PRE
><P
>          This function will store a new message in the given folder.
          The message is given by a string in memory
          (<B
CLASS="COMMAND"
>message</B
>) and a size
          (<B
CLASS="COMMAND"
>size</B
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-GET-MESSAGES-LIST"
>mailfolder_get_messages_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_get_messages_list(struct mailfolder * folder,
    struct mailmessage_list ** result);
        </PRE
><P
>          This function will return the list of messages in the given
          folder (see <A
HREF="#MAILMESSAGE-LIST"
>the Section called <I
>Message list</I
></A
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-GET-ENVELOPES-LIST"
>mailfolder_get_envelopes_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_get_envelopes_list(struct mailfolder * folder,
    struct mailmessage_list * result);
        </PRE
><P
>          This function will fill the list of parsed header fields
          structure in the <B
CLASS="COMMAND"
>mailmessage</B
> structures
          of the given list of messages (<B
CLASS="COMMAND"
>result</B
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-GET-MESSAGE"
>mailfolder_get_message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_get_message(struct mailfolder * folder,
    uint32_t num, mailmessage ** result);
        </PRE
><P
>          This function will return the message identified by a
          message index (<B
CLASS="COMMAND"
>num</B
>)
          This will return a <B
CLASS="COMMAND"
>mailmessage</B
> structure
          in <B
CLASS="COMMAND"
>(* result)</B
> (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILFOLDER-GET-MESSAGE-BY-UID"
>mailfolder_get_message_by_uid</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>int mailfolder_get_message_by_uid(struct mailfolder * folder,
    const char * uid, mailmessage ** result);
        </PRE
><P
>          This function will return the message identified by a
          unique identifier (<B
CLASS="COMMAND"
>uid</B
>)
          This will return a <B
CLASS="COMMAND"
>mailmessage</B
> structure
          in <B
CLASS="COMMAND"
>(* result)</B
> (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3193"
>Example</A
></H3
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN3195"
></A
><P
><B
>Example 5-2. use of folder</B
></P
><PRE
CLASS="PROGRAMLISTING"
>int main(void)
{
  struct mailstorage * storage;
  int r;

  storage = mailstorage_new(NULL);
  
  imap_mailstorage_init(storage, "imap.my-servers.org", 0,
    NULL, CONNECTION_TYPE_TRY_STARTTLS, IMAP_AUTH_TYPE_PLAIN,
    "my-login", "my-password", 1, "/home/login/.libetpan/cache");

  r = mailstorage_connect(storage);
  if (r == MAIL_NO_ERROR) {
    struct mailfolder * folder;

    folder = mailfolder_new(storage, "INBOX", NULL);
    
    r = mailfolder_connect(folder);
    if (r == MAIL_NO_ERROR) {
      struct mailmessage_list * msg_list;
      
      mailfolder_get_messages_list(folder, &amp;msg_list);
      
      /* do the things */
      
      mailmessage_list_free(msg_list);
      
      mailfolder_disconnect(folder);
    }
    
    mailstorage_disconnect(storage);
  }
  
  mailstorage_free(storage);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3198"
>Message</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-DRIVER"
>Message driver</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmessage_driver {
  char * msg_name;

  int (* msg_initialize)(mailmessage * msg_info);
  
  void (* msg_uninitialize)(mailmessage * msg_info);
  
  void (* msg_flush)(mailmessage * msg_info);

  void (* msg_check)(mailmessage * msg_info);

  void (* msg_fetch_result_free)(mailmessage * msg_info,
			     char * msg);

  int (* msg_fetch)(mailmessage * msg_info,
		char ** result,
		size_t * result_len);
       
  int (* msg_fetch_header)(mailmessage * msg_info,
		       char ** result,
		       size_t * result_len);
  
  int (* msg_fetch_body)(mailmessage * msg_info,
		     char ** result, size_t * result_len);

  int (* msg_fetch_size)(mailmessage * msg_info,
		     size_t * result);
  
  int (* msg_get_bodystructure)(mailmessage * msg_info,
			    struct mailmime ** result);
  
  int (* msg_fetch_section)(mailmessage * msg_info,
			struct mailmime * mime,
			char ** result, size_t * result_len);
  
  int (* msg_fetch_section_header)(mailmessage * msg_info,
			       struct mailmime * mime,
			       char ** result,
			       size_t * result_len);
  
  int (* msg_fetch_section_mime)(mailmessage * msg_info,
			     struct mailmime * mime,
			     char ** result,
			     size_t * result_len);
  
  int (* msg_fetch_section_body)(mailmessage * msg_info,
			     struct mailmime * mime,
			     char ** result,
			     size_t * result_len);

  int (* msg_fetch_envelope)(mailmessage * msg_info,
			 struct mailimf_fields ** result);

  int (* msg_get_flags)(mailmessage * msg_info,
		    struct mail_flags ** result);
};
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>msg_name</B
> is the name of the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_initialize()</B
> will initialize the
              internal message state (field
              <B
CLASS="COMMAND"
>msg_data</B
> of
              <B
CLASS="COMMAND"
>mailmessage</B
> structure (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_uninitialize()</B
> will free the
              internal message state.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_flush()</B
> will release memory used
              by the MIME structure of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_check()</B
> will store the flags of
              the message into the session, so that the message can be
              released without the flags are lost.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_result_free()</B
> will free a
              string returned by any fetch_XXX() function.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch()</B
> will fetch a message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_header()</B
> will fetch the
              header fields of a message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_body()</B
> will fetch a message
              without its main header.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_size()</B
> will return the size
              of a message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_get_bodystructure</B
> will retrieve
              the MIME structure of the message. The returned
              structure must <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be freed.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_section()</B
> will fetch the
              content of the section of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_section_header()</B
> will fetch
              the header of a section of the message if the content of
              the section is a message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_section_mime()</B
> will fetch
              the MIME header of a section of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_section_body()</B
> will fetch
              the body of a section (without the headers) of the
              message if the content of the section is a message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fetch_envelope()</B
> will return
              a given number of parsed header fields.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_get_flags()</B
> will return the
              flags of the message.
              The returned structure must <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
> be
              freed.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE"
>Message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmessage {
  mailsession * msg_session;
  mailmessage_driver * msg_driver;
  uint32_t msg_index;
  char * msg_uid;

  size_t msg_size;
  struct mailimf_fields * msg_fields;
  struct mail_flags * msg_flags;

  int msg_resolved;
  struct mailimf_single_fields msg_single_fields;
  struct mailmime * msg_mime;

  /* internal data */

  int msg_cached;
  void * msg_data;
  
 /*
   msg_folder field :
   used to reference the mailfolder, this is a workaround due
   to the problem with initial conception, where folder notion
   did not exist.
 */
  void * msg_folder;
  /* user data */
  void * msg_user_data;
};
        </PRE
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>msg_session</B
> is the session related to
              the message
              (see <A
HREF="#MAILSESSION"
>the Section called <I
>Session</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_driver</B
> is the driver used for the
              message
              (see <A
HREF="#MAILMESSAGE-DRIVER"
>the Section called <I
>Message driver</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_index</B
> is an index to indentify
              the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_uid</B
> is the unique identifier of
              the message, valid accross disconnections.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_size</B
> is the size of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_fields</B
> is the list of parsed
              header fields of the message. This can be
              <B
CLASS="COMMAND"
>NULL</B
>
              (see <A
HREF="#MAILIMF-FIELDS"
>the Section called <I
>mailimf_fields - list of header fields</I
> in Chapter 3</A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_flags</B
> is the flags of the
              message. This can be <B
CLASS="COMMAND"
>NULL</B
>
              (see <A
HREF="#MAIL-FLAGS"
>the Section called <I
>Message flags</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_resolved</B
> will tell if the field
              <B
CLASS="COMMAND"
>msg_single_fields</B
> has been initialized.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_single_fields</B
> will be filled
              using <B
CLASS="COMMAND"
>msg_fields</B
>
              (see <A
HREF="#MAILIMF-SINGLE-FIELDS"
>the Section called <I
>mailimf_single_fields - simplified fields</I
> in Chapter 3</A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_mime</B
> is the MIME structure of the 
              message. It is intialized at least when
              <B
CLASS="COMMAND"
>get_bodystructure()</B
> is called once.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_cached</B
> is 1 when the message was
              cached. This is used internally.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_data</B
> is the internal state of the
              message. The content depends on the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_folder</B
> is used to reference the
              mailfolder, this is a workaround due to the problem with
              initial conception, where folder notion did not exist.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>msg_user_data</B
> is a field for free
              use. The user can store any data in that field.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-NEW"
>mailmessage_new</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

mailmessage * mailmessage_new(void);

void mailmessage_free(mailmessage * info);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmessage_new()</B
> will create a new
          message (without driver). This is used internally by
          drivers.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmessage_free()</B
> will free the memory
          used by the given message.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-INIT"
>mailmessage_init</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_init(mailmessage * msg_info,
		     mailsession * session,
		     mailmessage_driver * driver,
		     uint32_t index, size_t size);
        </PRE
><P
>          <B
CLASS="COMMAND"
>mailmessage_init()</B
> will initialize a
          message with a driver.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>msg_info</B
> is the message to initialize
              (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>session</B
> is the session related to the
              message
              (see <A
HREF="#MAILSESSION"
>the Section called <I
>Session</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>driver</B
> is the driver to use for the
              message
              (see <A
HREF="#MAILMESSAGE-DRIVER"
>the Section called <I
>Message driver</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>index</B
> is the index of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>size</B
> is the size of the message.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FLUSH"
>mailmessage_flush</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_flush(mailmessage * info);
        </PRE
><P
>          This function will release the memory used by the MIME
          structure of the message.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-CHECK"
>mailmessage_check</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_check(mailmessage * info);
        </PRE
><P
>          After you set some flags, if you want to notify them to the
          session before destroying the message, you can use this function.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-RESULT-FREE"
>mailmessage_fetch_result_free</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_result_free(mailmessage * msg_info,
				  char * msg);
        </PRE
><P
>          This function will free a string returned by any
          mailmessage_fetch_XXX() function.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH"
>mailmessage_fetch</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch(mailmessage * msg_info,
		      char ** result,
		      size_t * result_len);
        </PRE
><P
>          This function returns the content of the message (headers
          and text).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-HEADER"
>mailmessage_fetch_header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_header(mailmessage * msg_info,
			     char ** result,
			     size_t * result_len);
        </PRE
><P
>          This function returns the header of the message as a string.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-BODY"
>mailmessage_fetch_body</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_body(mailmessage * msg_info,
			   char ** result, size_t * result_len);
        </PRE
><P
>          This function returns the content of the message (without
          headers).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-SIZE"
>mailmessage_fetch_size</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_size(mailmessage * msg_info,
			   size_t * result);
        </PRE
><P
>          This function returns the size of the message content.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-GET-BODYSTRUCTURE"
>mailmessage_get_bodystructure</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_get_bodystructure(mailmessage * msg_info,
				  struct mailmime ** result);
        </PRE
><P
>          This functions returns the MIME structure of the message.
          The returned information <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>MUST</I
></SPAN
> not be
          freed by hand. It is freed by
          <B
CLASS="COMMAND"
>mailmessage_flush()</B
> or
          <B
CLASS="COMMAND"
>mailmessage_free()</B
>
          (see <A
HREF="#MAILMIME"
>the Section called <I
>mailmime - MIME part</I
> in Chapter 4</A
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-SECTION"
>mailmessage_fetch_section</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_section(mailmessage * msg_info,
			      struct mailmime * mime,
			      char ** result, size_t * result_len);
        </PRE
><P
>          This function returns the content of a MIME part.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-SECTION-HEADER"
>mailmessage_fetch_section_header</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_section_header(mailmessage * msg_info,
				     struct mailmime * mime,
				     char ** result,
				     size_t * result_len);
        </PRE
><P
>          This function returns the header of the message contained
          in the given MIME part.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-SECTION-MIME"
>mailmessage_fetch_section_mime</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_section_mime(mailmessage * msg_info,
				   struct mailmime * mime,
				   char ** result,
				   size_t * result_len);
        </PRE
><P
>          This function returns the MIME header of the given MIME
          part.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-SECTION-BODY"
>mailmessage_fetch_section_body</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_section_body(mailmessage * msg_info,
				   struct mailmime * mime,
				   char ** result,
				   size_t * result_len);
        </PRE
><P
>          This function returns the text part of the message contained
          in the given MIME part.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-FETCH-ENVELOPE"
>mailmessage_fetch_envelope</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_fetch_envelope(mailmessage * msg_info,
			       struct mailimf_fields ** result);
        </PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-GET-FLAGS"
>mailmessage_get_flags</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailmessage_get_flags(mailmessage * msg_info,
			  struct mail_flags ** result);
        </PRE
><P
>          This function returns the flags related to the message.
          The returned information MUST not be freed by hand. It is freed by
          <B
CLASS="COMMAND"
>mailmessage_free()</B
>.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-RESOLVE-SINGLE-FIELDS"
>mailmessage_resolve_single_fields</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

void mailmessage_resolve_single_fields(mailmessage * msg_info);
        </PRE
><P
>          This function will use the fields information to fill
          the single_fields structure in the mailmessage structure.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-LIST"
>Message list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmessage_list {
  carray * msg_tab; /* elements are (mailmessage *) */
};

struct mailmessage_list * mailmessage_list_new(carray * msg_tab);

void mailmessage_list_free(struct mailmessage_list * env_list);
        </PRE
><P
>          This is a list of messages.
        </P
><P
>          <B
CLASS="COMMAND"
>msg_tab</B
> is an array containing the
          messages (see linkend="carray").
        </P
><P
>          <B
CLASS="COMMAND"
>mailmessage_list_new()</B
> will initialize a
          list of messages, using a given array of messages.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmessage_list_free()</B
> will free the
          memory used by the list of messages. This will also free the
          messages.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILMESSAGE-TREE"
>Message tree</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailmessage_tree {
  struct mailmessage_tree * node_parent;
  char * node_msgid;
  time_t node_date;
  mailmessage * node_msg;
  carray * node_children; /* array of (struct mailmessage_tree *) */

  /* private, used for threading */
  int node_is_reply;
  char * node_base_subject;
};


struct mailmessage_tree *
mailmessage_tree_new(char * node_msgid, time_t node_date,
    mailmessage * node_msg);

void mailmessage_tree_free(struct mailmessage_tree * tree);

void mailmessage_tree_free_recursive(struct mailmessage_tree * tree);
        </PRE
><P
>          This is a node of a tree of messages.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>node_parent</B
> is the parent of this
              node.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_msgid</B
> is the content of the
              field <B
CLASS="COMMAND"
>Message-ID</B
> of the message.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_date</B
> is the date in UNIX
              format.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_msg</B
> is the message of the node.
              The message should have the <B
CLASS="COMMAND"
>msg_fields</B
>
              field initialized.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_children</B
> is the list of
              children of this node.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_is_reply</B
> is set to 1 if the
              message is a reply.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>node_base_subject</B
> is the base subject
              of the message (base subject is defined in definition of
              IMAP thread draft). 
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailmessage_tree_new()</B
> will initialize a
          message node.
        </P
><P
>          <B
CLASS="COMMAND"
>mailmessage_tree_free()</B
> will release
          memory used by the node. This will <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>NOT</I
></SPAN
>
          free the message.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAIL-FLAGS"
>Message flags</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

enum {
  MAIL_FLAG_NEW       = 1 &lt;&lt; 0,
  MAIL_FLAG_SEEN      = 1 &lt;&lt; 1,
  MAIL_FLAG_FLAGGED   = 1 &lt;&lt; 2,
  MAIL_FLAG_DELETED   = 1 &lt;&lt; 3,
  MAIL_FLAG_ANSWERED  = 1 &lt;&lt; 4,
  MAIL_FLAG_FORWARDED = 1 &lt;&lt; 5,
  MAIL_FLAG_CANCELLED = 1 &lt;&lt; 6,
};

struct mail_flags {
  uint32_t fl_flags;
  clist * fl_extension; /* elements are (char *) */
};

struct mail_flags * mail_flags_new(uint32_t fl_flags, clist * fl_ext);

void mail_flags_free(struct mail_flags * flags);

int mail_flags_add_extension(struct mail_flags * flags,
			     char * ext_flag);

int mail_flags_remove_extension(struct mail_flags * flags,
				char * ext_flag);

int mail_flags_has_extension(struct mail_flags * flags,
			     char * ext_flag);
        </PRE
><P
>          This is the structure containing the message flags.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>fl_flags</B
> will contain the standards
              flags. The value will be a combinaison (with or binary
              operation) of <B
CLASS="COMMAND"
>MAIL_FLAG_XXX</B
> values.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>fl_extension</B
> will be a list (see
              <A
HREF="#CLIST"
>the Section called <I
>List</I
> in Chapter 2</A
>) of strings representing the
              non-standard flags.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3467"
>Example</A
></H3
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN3469"
></A
><P
><B
>Example 5-3. use of message</B
></P
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

#define DEST_CHARSET "iso-8859-1"

enum {
  NO_ERROR,
  ERROR_FILE,
  ERROR_MEMORY,
  ERROR_INVAL,
  ERROR_FETCH,
};

/* returns TRUE is given MIME part is a text part */

int etpan_mime_is_text(struct mailmime * build_info)
{
  if (build_info-&gt;mm_type == MAILMIME_SINGLE) {
    if (build_info-&gt;mm_content_type != NULL) {
      if (build_info-&gt;mm_content_type-&gt;ct_type-&gt;tp_type ==
          MAILMIME_TYPE_DISCRETE_TYPE) {
        if (build_info-&gt;mm_content_type-&gt;ct_type-&gt;tp_data.tp_discrete_type-&gt;dt_type ==
            MAILMIME_DISCRETE_TYPE_TEXT)
          return 1;
      }
    }
    else
      return 1;
  }

  return 0;
}


/* display content type */

int show_part_info(FILE * f,
    struct mailmime_single_fields * mime_fields,
    struct mailmime_content * content)
{
  char * description;
  char * filename;
  int col;
  int r;

  description = mime_fields-&gt;fld_description;
  filename = mime_fields-&gt;fld_disposition_filename;

  col = 0;

  r = fprintf(f, " [ Part ");
  if (r &lt; 0)
    goto err;

  if (content != NULL) {
    r = mailmime_content_type_write(f, &amp;col, content);
    if (r != MAILIMF_NO_ERROR)
      goto err;
  }

  if (filename != NULL) {
    r = fprintf(f, " (%s)", filename);
    if (r &lt; 0)
      goto err;
  }

  if (description != NULL) {
    r = fprintf(f, " : %s", description);
    if (r &lt; 0)
      goto err;
  }

  r = fprintf(f, " ]\n\n");
  if (r &lt; 0)
    goto err;

  return NO_ERROR;
  
 err:
  return ERROR_FILE;
}

/* fetch message and decode if it is base64 or quoted-printable */

int etpan_fetch_message(mailmessage * msg_info,
    struct mailmime * mime_part,
    struct mailmime_single_fields * fields,
    char ** result, size_t * result_len)
{
  char * data;
  size_t len;
  int r;
  int encoding;
  char * decoded;
  size_t decoded_len;
  size_t cur_token;
  int res;
  int encoded;

  encoded = 0;

  r = mailmessage_fetch_section(msg_info,
      mime_part, &amp;data, &amp;len);
  if (r != MAIL_NO_ERROR) {
    res = ERROR_FETCH;
    goto err;
  }

  encoded = 1;

  /* decode message */

  if (encoded) {
    if (fields-&gt;fld_encoding != NULL)
      encoding = fields-&gt;fld_encoding-&gt;enc_type;
    else 
      encoding = MAILMIME_MECHANISM_8BIT;
  }
  else {
    encoding = MAILMIME_MECHANISM_8BIT;
  }

  cur_token = 0;
  r = mailmime_part_parse(data, len, &amp;cur_token,
			  encoding, &amp;decoded, &amp;decoded_len);
  if (r != MAILIMF_NO_ERROR) {
    res = ERROR_FETCH;
    goto free; 
  }

  mailmessage_fetch_result_free(msg_info, data);
  
  * result = decoded;
  * result_len = decoded_len;
  
  return NO_ERROR;
  
 free:
  mailmessage_fetch_result_free(msg_info, data);
 err:
  return res;
}

/* fetch fields */

struct mailimf_fields * fetch_fields(mailmessage * msg_info,
    struct mailmime * mime)
{
  char * data;
  size_t len;
  int r;
  size_t cur_token;
  struct mailimf_fields * fields;

  r = mailmessage_fetch_section_header(msg_info, mime,
    &amp;data, &amp;len);
  if (r != MAIL_NO_ERROR)
    return NULL;

  cur_token = 0;
  r = mailimf_envelopes_fields_parse(data, len,
    &amp;cur_token, &amp;fields);
  if (r != MAILIMF_NO_ERROR) {
    mailmessage_fetch_result_free(msg_info, data);
    return NULL;
  }

  mailmessage_fetch_result_free(msg_info, data);

  return fields;
}

/* render message */

static int etpan_render_mime(FILE * f, mailmessage * msg_info,
    struct mailmime * mime)
{
  int r;
  clistiter * cur;
  int col;
  int text;
  int show;
  struct mailmime_single_fields fields;
  int res;

  mailmime_single_fields_init(&amp;fields, mime-&gt;mm_mime_fields,
      mime-&gt;mm_content_type);
  
  text = etpan_mime_is_text(mime);
  
  r = show_part_info(f, &amp;fields, mime-&gt;mm_content_type);
  if (r != NO_ERROR) {
    res = r;
    goto err;
  }

  switch(mime-&gt;mm_type) {
  case MAILMIME_SINGLE:
    show = 0;
    if (text)
      show = 1;
    
    if (show) {
      char * data;
      size_t len;
      char * converted;
      size_t converted_len;
      char * source_charset;
      size_t write_len;

      /* viewable part */
          
      r = etpan_fetch_message(msg_info, mime,
          &amp;fields, &amp;data, &amp;len);
      if (r != NO_ERROR) {
        res = r;
        goto err;
      }
          
      source_charset = fields.fld_content_charset;
      if (source_charset == NULL)
        source_charset = DEST_CHARSET;
      
      r = charconv_buffer(source_charset, DEST_CHARSET,
          data, len, &amp;converted, &amp;converted_len);
      if (r != MAIL_CHARCONV_NO_ERROR) {
        
        r = fprintf(f, "[ error converting charset from %s to %s ]\n",
            source_charset, DEST_CHARSET);
          if (r &lt; 0) {
            res = ERROR_FILE;
            goto err;
          }
          
          write_len = fwrite(data, 1, len, f);
          if (write_len != len) {
            mailmime_decoded_part_free(data);
            res = r;
            goto err;
          }
        }
        else {
          write_len = fwrite(converted, 1, converted_len, f);
          if (write_len != len) {
            charconv_buffer_free(converted);
            mailmime_decoded_part_free(data);
            res = r;
            goto err;
          }
              
          charconv_buffer_free(converted);
        }
            
        write_len = fwrite("\r\n\r\n", 1, 4, f);
        if (write_len &lt; 4) {
          mailmime_decoded_part_free(data);
          res = ERROR_FILE;
          goto err;
        }
          
      mailmime_decoded_part_free(data);
    }
    else {
      /* not viewable part */

      r = fprintf(f, "   (not shown)\n\n");
      if (r &lt; 0) {
        res = ERROR_FILE;
        goto err;
      }
    }

    break;
    
  case MAILMIME_MULTIPLE:

    if (strcasecmp(mime-&gt;mm_content_type-&gt;ct_subtype,
      "alternative") == 0) {
      struct mailmime * prefered_body;
      int prefered_score;

      /* case of multiple/alternative */

      /*
        we choose the better part,
        alternative preference :

	text/plain =&gt; score 3
	text/xxx   =&gt; score 2
	other      =&gt; score 1
      */

      prefered_body = NULL;
      prefered_score = 0;

      for(cur = clist_begin(mime-&gt;mm_data.mm_multipart.mm_mp_list) ;
          cur != NULL ; cur = clist_next(cur)) {
	struct mailmime * submime;
	int score;

	score = 1;
	submime = clist_content(cur);
        if (etpan_mime_is_text(submime))
          score = 2;

	if (submime-&gt;mm_content_type != NULL) {
          if (strcasecmp(submime-&gt;mm_content_type-&gt;ct_subtype,
            "plain") == 0)
            score = 3;
	}

	if (score &gt; prefered_score) {
	  prefered_score = score;
	  prefered_body = submime;
	}
      }

      if (prefered_body != NULL) {
	r = etpan_render_mime(f, msg_info, prefered_body);
	if (r != NO_ERROR) {
	  res = r;
          goto err;
        }
      }
    }
    else {
      for(cur = clist_begin(mime-&gt;mm_data.mm_multipart.mm_mp_list) ;
          cur != NULL ; cur = clist_next(cur)) {
        
        r = etpan_render_mime(f, msg_info, clist_content(cur));
        if (r != NO_ERROR) {
          res = r;
          goto err;
        }
      }
    }

    break;
      
  case MAILMIME_MESSAGE:

    if (mime-&gt;mm_data.mm_message.mm_fields != NULL) {
      struct mailimf_fields * fields;
      
      if (msg_info != NULL) {
        fields = fetch_fields(msg_info, mime);
        if (fields == NULL) {
          res = ERROR_FETCH;
          goto err;
        }
        
        col = 0;
        r = mailimf_fields_write(f, &amp;col, fields);
        if (r != NO_ERROR) {
          mailimf_fields_free(fields);
          res = r;
          goto err;
        }
        
        mailimf_fields_free(fields);
      }
      else {
        col = 0;
        r = fields_write(f, &amp;col, mime-&gt;mm_data.mm_message.mm_fields);
        if (r != NO_ERROR) {
          res = r;
          goto err;
        }
      }
      
      r = fprintf(f, "\r\n");
      if (r &lt; 0) {
        res = ERROR_FILE;
        goto err;
      }
    }
    
    if (mime-&gt;mm_data.mm_message.mm_msg_mime != NULL) {
      r = etpan_render_mime(f, msg_info,
        mime-&gt;mm_data.mm_message.mm_msg_mime);
      if (r != NO_ERROR) {
        res = r;
        goto err;
      }
    }

    break;
  }

  return NO_ERROR;

 err:
  return res;
}



int main(void)
{
  struct mailstorage * storage;
  int r;

  storage = mailstorage_new(NULL);
  
  imap_mailstorage_init(storage, "imap.my-servers.org", 0,
    NULL, CONNECTION_TYPE_TRY_STARTTLS, IMAP_AUTH_TYPE_PLAIN,
    "my-login", "my-password", 1, "/home/login/.libetpan/cache");

  r = mailstorage_connect(storage);
  if (r == MAIL_NO_ERROR) {
    struct mailfolder * folder;

    folder = mailfolder_new(storage, "INBOX", NULL);
    
    r = mailfolder_connect(folder);
    if (r == MAIL_NO_ERROR) {
      struct mailmessage_list * msg_list;
      mailmessage * msg;
      
      mailfolder_get_messages_list(folder, &amp;msg_list);
      
      if (carray_count(msg_list-&gt;msg_tab) &gt; 0) {
        struct mailmime * mime;
      
        msg = carray_get(msg_list-&gt;msg_tab, 0);
        
        mailmessage_get_bodystructure(msg, &amp;mime);
        
        recursive_fetch(msg, mime);
        
        /* do the things */
        
        mailmessage_flush(msg);
      }
      mailmessage_list_free(msg_list);
      
      mailfolder_disconnect(folder);
    }
    
    mailstorage_disconnect(storage);
  }
  
  mailstorage_free(storage);
}
          </PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3472"
>Session</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="MAILSESSION-DRIVER"
>Session driver</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailsession_driver {
  char * sess_name;

  int (* sess_initialize)(mailsession * session);
  void (* sess_uninitialize)(mailsession * session);

  int (* sess_parameters)(mailsession * session,
      int id, void * value);

  int (* sess_connect_stream)(mailsession * session, mailstream * s);
  int (* sess_connect_path)(mailsession * session, char * path);

  int (* sess_starttls)(mailsession * session);

  int (* sess_login)(mailsession * session, char * userid, char * password);
  int (* sess_logout)(mailsession * session);
  int (* sess_noop)(mailsession * session);

  /* folders operations */

  int (* sess_build_folder_name)(mailsession * session, char * mb,
      char * name, char ** result);

  int (* sess_create_folder)(mailsession * session, char * mb);
  int (* sess_delete_folder)(mailsession * session, char * mb);
  int (* sess_rename_folder)(mailsession * session, char * mb,
      char * new_name);
  int (* sess_check_folder)(mailsession * session);
  int (* sess_examine_folder)(mailsession * session, char * mb);
  int (* sess_select_folder)(mailsession * session, char * mb);
  int (* sess_expunge_folder)(mailsession * session);
  int (* sess_status_folder)(mailsession * session, char * mb,
      uint32_t * result_num, uint32_t * result_recent,
      uint32_t * result_unseen);
  int (* sess_messages_number)(mailsession * session, char * mb,
      uint32_t * result);
  int (* sess_recent_number)(mailsession * session, char * mb,
      uint32_t * result);
  int (* sess_unseen_number)(mailsession * session, char * mb,
      uint32_t * result);

  int (* sess_list_folders)(mailsession * session, char * mb,
      struct mail_list ** result);
  int (* sess_lsub_folders)(mailsession * session, char * mb,
      struct mail_list ** result);

  int (* sess_subscribe_folder)(mailsession * session, char * mb);
  int (* sess_unsubscribe_folder)(mailsession * session, char * mb);

  /* messages operations */

  int (* sess_append_message)(mailsession * session,
      char * message, size_t size);
  int (* sess_copy_message)(mailsession * session,
      uint32_t num, char * mb);
  int (* sess_move_message)(mailsession * session,
      uint32_t num, char * mb);

  int (* sess_get_message)(mailsession * session,
      uint32_t num, mailmessage ** result);

  int (* sess_get_message_by_uid)(mailsession * session,
      const char * uid, mailmessage ** result);
  
  int (* sess_get_messages_list)(mailsession * session,
      struct mailmessage_list ** result);
  int (* sess_get_envelopes_list)(mailsession * session,
      struct mailmessage_list * env_list);
  int (* sess_remove_message)(mailsession * session, uint32_t num);
};
        </PRE
><P
>          This is a driver for a session.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sess_name</B
> is the name of the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_initialize()</B
> is the function
              that will initializes a data structure (field
              <B
CLASS="COMMAND"
>sess_data</B
> in the session) specific to
              the driver.
              The field data (field <B
CLASS="COMMAND"
>sess_data</B
> in
              the session) is the state of the session,
              the internal data structure used by the driver.
              It is called when creating the
              <B
CLASS="COMMAND"
>mailsession</B
> structure with
              <B
CLASS="COMMAND"
>mailsession_new()</B
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_uninitialize()</B
> frees the structure
              created with <B
CLASS="COMMAND"
>sess_initialize()</B
>
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_parameters()</B
> implements
              functions specific to the given mail access.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_connect_stream()</B
> connects a
              stream to the session.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_connect_path()</B
> notify a main
              path to the session.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_starttls()</B
> changes the current
              stream to a TLS stream
              (see <A
HREF="#MAILSTREAM-SSL"
>the Section called <I
>TLS stream</I
> in Chapter 2</A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_login()</B
> notifies the user and
              the password to authenticate to the session.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_logout()</B
> exits the session and
              closes the stream.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_noop()</B
> does no operation on the
              session, but it can be used to poll for the status of
              the connection.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_build_folder_name()</B
> will return an
              allocated string with that contains the complete path of
              the folder to create.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_create_folder()</B
> creates the
              folder that corresponds to the given name.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_delete_folder()</B
> deletes the folder
              that corresponds to the given name.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_rename_folder()</B
> change the name
              of the folder.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_check_folder()</B
> makes a
              checkpoint of the session.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_examine_folder()</B
> selects a mailbox as
              readonly.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_select_folder()</B
> selects a mailbox.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_expunge_folder()</B
> deletes all
              messages marked \Deleted.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_status_folder()</B
> queries the
              status of the folder (number of messages, number of
              recent messages, number of unseen messages).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_messages_number()</B
> queries the
              number of messages in the folder.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_recent_number()</B
> queries the
              number of recent messages in the folder.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_unseen_number()</B
> queries the number of
              unseen messages in the folder.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_list_folders()</B
> returns the list of
              all sub-mailboxes of the given mailbox.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_lsub_folders()</B
> returns the list of
              subscribed sub-mailboxes of the given mailbox.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_subscribe_folder()</B
> subscribes to
              the given mailbox.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_unsubscribe_folder()</B
> unsubscribes to
              the given mailbox.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_append_message()</B
> adds a RFC 2822
              message to the current given mailbox.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_copy_message()</B
> copies a message
              whose number is given to a given mailbox. The mailbox
              must be accessible from the same session.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
          </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_move_message()</B
> moves a message whose
              number is given to
              a given mailbox. The mailbox must be accessible from the
              same session.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_messages_list()</B
> returns the list
              of message numbers
              of the current mailbox
              (see <A
HREF="#MAILMESSAGE-LIST"
>the Section called <I
>Message list</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_envelopes_list()</B
> fills the parsed
              fields in the <B
CLASS="COMMAND"
>mailmessage</B
> structures
              (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>)
              of the <B
CLASS="COMMAND"
>mailmessage_list</B
>
              (see <A
HREF="#MAILMESSAGE-LIST"
>the Section called <I
>Message list</I
></A
>).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_remove_message()</B
> removes the given
              message from the mailbox.
              The message is permanently deleted.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_message()</B
> returns a
              mailmessage structure
              (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>)
              that corresponds
              to the given message number.
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Use of this method is deprecated</I
></SPAN
>.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_message_by_uid()</B
> returns a
              mailmessage structure
              (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>)
              that corresponds 
              to the given message unique identifier.
            </P
></LI
></UL
><P
>          mandatory functions are the following :
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sess_connect_stream()</B
> or
              <B
CLASS="COMMAND"
>connect_path()</B
>
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_logout()</B
>
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_messages_list()</B
>
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_envelopes_list()</B
>
            </P
></LI
></UL
><P
>          we advise you to implement these functions :
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sess_select_folder()</B
> (in case a session
              can access several folders).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_noop()</B
> (to check if the server is
              responding)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_check_folder()</B
> (to make a checkpoint
              of the session)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_status_folder()</B
>,
              <B
CLASS="COMMAND"
>sess_messages_number()</B
>,
              <B
CLASS="COMMAND"
>sess_recent_number()</B
>,
              <B
CLASS="COMMAND"
>sess_unseen_number()</B
>
              (to get stat of the folder)
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_append_message()</B
> (but can't be done
              in the case of POP3 at least).
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_login()</B
> in a case of an
              authenticated driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_starttls()</B
> in a case of a stream
              driver, if the procotol supports STARTTLS.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_get_message_by_uid()</B
> so that the
              application can remember the messages 
              by UID and build its own list of messages.
            </P
></LI
><LI
><P
>              Everything that is specific to the driver will be
              implemented in <B
CLASS="COMMAND"
>sess_parameters()</B
>.
            </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAILSESSION"
>Session</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

struct mailsession {
  void * sess_data;
  mailsession_driver * sess_driver;
};

mailsession * mailsession_new(mailsession_driver * sess_driver);

void mailsession_free(mailsession * session);
        </PRE
><P
>          This is a session. This is an abstraction used to access the
          storage, using the network or the filesystem.
        </P
><P
></P
><UL
><LI
><P
>              <B
CLASS="COMMAND"
>sess_data</B
> is the state of the
              session. This is specific to the driver.
            </P
></LI
><LI
><P
>              <B
CLASS="COMMAND"
>sess_driver</B
> is the driver of the
              session.
            </P
></LI
></UL
><P
>          <B
CLASS="COMMAND"
>mailsession_new()</B
> will create a new session
          using the given driver (<B
CLASS="COMMAND"
>sess_driver</B
>).
        </P
><P
>          <B
CLASS="COMMAND"
>mailsession_free()</B
> will release the memory
          used by the session.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3670"
>mailsession_parameters</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_parameters(mailsession * session,
			   int id, void * value);
        </PRE
><P
>          This function make calls specific to the driver
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3674"
>mailsession_connect_stream</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_connect_stream(mailsession * session, mailstream * s);
        </PRE
><P
>          There are drivers of two kinds : stream drivers (driver that
          connects to servers through TCP or other means of connection)
          and file drivers (driver that are based on filesystem)

          This function can only be used by stream drivers and
          this connects a stream to the session
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3678"
>mailsession_connect_path</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_connect_path(mailsession * session, char * path);
        </PRE
><P
>          This function can only be used by file drivers and
          selects the main path of the session.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3682"
>mailsession_starttls</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_starttls(mailsession * session);
        </PRE
><P
>          This switches the current connection to TLS (secure layer).
          This will only work with stream drivers.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3686"
>mailsession_login</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_login(mailsession * session,
		      char * userid, char * password);
        </PRE
><P
>          This notifies the login and the password to authenticate
          to the session.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3690"
>mailsession_logout</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_logout(mailsession * session);
        </PRE
><P
>          This function disconnects the session and closes the stream.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3694"
>mailsession_noop</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_noop(mailsession * session);
        </PRE
><P
>          This function does no operation on the session, but it can be
          used to poll for the status of the connection.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3698"
>mailsession_check_folder</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_check_folder(mailsession * session);
        </PRE
><P
>          This function makes a checkpoint of the session.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3702"
>mailsession_select_folder</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_select_folder(mailsession * session, char * mb);
        </PRE
><P
>          This function selects a mailbox.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3706"
>mailsession_expunge_folder</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_expunge_folder(mailsession * session);
        </PRE
><P
>          This function deletes all messages marked for deletion.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3710"
>mailsession_status_folder</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_status_folder(mailsession * session, char * mb,
    uint32_t * result_messages, uint32_t * result_recent,
    uint32_t * result_unseen);
        </PRE
><P
>          This function queries the status of the folder
          (number of messages, number of recent messages, number of
          unseen messages).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3714"
>mailsession_messages_number</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_messages_number(mailsession * session, char * mb,
				uint32_t * result);
        </PRE
><P
>          This function queries the number of messages in the folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3718"
>mailsession_recent_number</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_recent_number(mailsession * session,
			      char * mb, uint32_t * result);
        </PRE
><P
>          This function queries the number of recent messages in the
          folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3722"
>mailsession_unseen_number</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_unseen_number(mailsession * session, char * mb,
			      uint32_t * result);
        </PRE
><P
>          This function queries the number of unseen messages in the
          folder.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3726"
>mailsession_append_message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_append_message(mailsession * session,
			       char * message, size_t size);
        </PRE
><P
>          This adds a RFC 2822 message to the current mailbox.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3730"
>mailsession_get_messages_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_get_messages_list(mailsession * session,
				  struct mailmessage_list ** result);
        </PRE
><P
>          This function returns the list of messages
          of the current mailbox.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3734"
>mailsession_get_envelopes_list</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_get_envelopes_list(mailsession * session,
				   struct mailmessage_list * result);
        </PRE
><P
>          This function fills the parsed fields in the
          <B
CLASS="COMMAND"
>mailmessage</B
> structures
          (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>)
          of the mailmessage_list
          (see <A
HREF="#MAILMESSAGE-LIST"
>the Section called <I
>Message list</I
></A
>).
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3741"
>mailsession_get_message</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_get_message(mailsession * session,
			    uint32_t num, mailmessage ** result);
        </PRE
><P
>          This function returns a <B
CLASS="COMMAND"
>mailmessage</B
>
          (see <A
HREF="#MAILMESSAGE"
>the Section called <I
>Message</I
></A
>) structure that
          corresponds to the given message number.
        </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>            <B
CLASS="COMMAND"
>mailsession_get_message_by_uid()</B
> should
            be used instead.
          </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3750"
>mailsession_get_message_by_uid</A
></H3
><PRE
CLASS="PROGRAMLISTING"
>#include &lt;libetpan/libetpan.h&gt;

int mailsession_get_message_by_uid(mailsession * session,
    const char * uid, mailmessage ** result);
        </PRE
><P
>          This function returns a mailmessage structure
          that corresponds to the given message unique identifier.
          This is currently implemented only for cached drivers.
        </P
><DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>Warning</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>            That deprecates the use of
            <B
CLASS="COMMAND"
>mailsession_get_message()</B
>.
          </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>